<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP | HTTP报文</title>
    <url>/HTTP-HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&#160; &#160; &#160; &#160;客户端与服务器端之间的通信，通过HTTP协议，以HTTP报文的形式来实现数据的交互。</p>
<p>&#160; &#160; &#160; &#160;HTTP报文是HTTP通信时发送的数据块，本文主要从以下几个方面介绍HTTP报文：HTTP报文结构、方法、状态码、首部。</p>
<h1 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h1><p>&#160; &#160; &#160; &#160;HTTP报文由三部分组成：状态行(请求行 | 响应行)、首部、主体。也有些书籍说是由首部和主体两部分组成，状态行包含在首部中，但绝大多数的说法是由三部分组成。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/1-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90.jpg" class>

</div>



<p>&#160; &#160; &#160; &#160;HTTP报文可以分为请求报文和响应报文；请求报文向服务器传达请求，响应报文将请求的结果返回给客户端。以下两图，分别是请求报文以及响应报文的结构图。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/2-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" class>

<pre><code>{% asset_img 3-响应报文结构图.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;HTTP报文以状态行开始，跟在后面的是HTTP首部，首部由多个首部字段构成，每行一个首部字段；HTTP首部后是一个空行，然后是报文主体。</p>
<p>&#160; &#160; &#160; &#160;可以看到，状态行和首部中的每行都是以回车符(\r，%0d，CR)和换行符(\n，%0a，LF)结束，这是因为HTTP规范中行应该使用CRLF结束。另外，首部和主体之间由一空行隔开，或者可以理解为HTTP首部的最后一个字段有两个CRLF。</p>
<p>&#160; &#160; &#160; &#160;与状态行和首部不同的是，主体是可选的，也就是说报文中不一定要有主体；另外状态行和首部是ASCII文本，主体可包含文本或二进制数据。</p>
<p>&#160; &#160; &#160; &#160;以上就是HTTP报文的大概结构，下面分别对这三部分进行简要描述。</p>
<h2 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h2><p>&#160; &#160; &#160; &#160;HTTP报文以状态行开始，请求报文中的状态行叫请求行，响应报文中的状态行叫响应行。</p>
<p>&#160; &#160; &#160; &#160;请求行由请求方法、URL、协议版本组成，这些字段都由空格分隔。</p>
<div align="center">
    {% asset_img 4-请求行.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;请求行表明要对哪个资源执行哪个方法，具体有哪些请求方法，文章后面会详细介绍。</p>
<p>&#160; &#160; &#160; &#160;响应行由协议版本、状态码、原因短语(状态码描述)组成。这些字段同样都由空格分隔。</p>
<div align="center">
    {% asset_img 5-响应行.jpg %}

</div>


<p>&#160; &#160; &#160; &#160;响应行表明了服务器对请求的处理结果，由状态码体现。值得注意的是，原因短语是数字状态码的可读版本，描述数字状态码的含义，便于人理解，只对人有意义，因此以下两种响应行都会被当作成功处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 NOT OK    </span><br><span class="line">HTTP/1.0 200 OK</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;HTTP协议将状态码分成了5类，在下面的章节中会详细介绍。</p>
<p>&#160; &#160; &#160; &#160;另外请求行和响应行中都包含HTTP版本号，其格式为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/&lt;major&gt;.&lt;minor&gt;</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;major是主版本号，minor是次版本号，使用版本号的目的是规范双方之间通信的格式。</p>
<h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><p>&#160; &#160; &#160; &#160;HTTP首部由多个首部字段构成，旨在向报文中添加一些通信过程中所需的重要信息。具体细节文章后面会介绍。</p>
<h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><p>&#160; &#160; &#160; &#160;报文主体包含了HTTP所要传输的内容，但并不是所有的报文都有主体。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>&#160; &#160; &#160; &#160;状态行部分讲到请求行中包含请求方法字段，请求方法告诉服务器要做什么。下图是HTTP规范中目前已定义的方法，红框中的是比较常用的方法。</p>
<div align="center">
    {% asset_img 6-方法.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;注意，不是所有的服务器都会实现这些方法，一般都会实现GET和POST方法。另外，请求方法需要大写。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>&#160; &#160; &#160; &#160;GET：获取/查询资源。是最常用的HTTP方法，常用于请求URL指定的资源，服务端经过处理将资源返回给客户端。</p>
<p>&#160; &#160; &#160; &#160;比如访问百度首页，请求包如下，百度的服务器收到请求后，将百度首页返回给浏览器。</p>
<div align="center">
    {% asset_img 7-get1.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;有时请求会传递一些参数给服务器，在GET方法中，这些参数会被包含在URL中，放在文件路径后面，用“ ? ”分隔，被称为查询字符串。查询字符串以键值对的形式存在，每个参数的键和值用“=”连接，不同参数之间用“&amp;”符号连接。(详情请看URL格式)</p>
<p>&#160; &#160; &#160; &#160;百度搜索google，抓包可以发现，google被当成了word参数的参数值，放在请求行的URL字段中。</p>
<div align="center">
    {% asset_img 8-get2.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;特意将请求报文全选，大家可以看到，首部字段下方有一空行，然后空行下面有一光标，这再次体现了HTTP报文的结构，也告诉大家，GET请求是不包含请求主体的。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>&#160; &#160; &#160; &#160;POST：传输实体主体。常用于向指定资源发送数据，指定的资源会对数据进行处理，然后将处理结果返回给客户端。数据被包含在请求主体中，一般用于表单提交、文件上传等。</p>
<div align="center">
    {% asset_img 9-post.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;以上是登录时的请求包，请求主体中包含了用户名、密码、验证码、是否记住用户名的参数数据，服务器接收到请求后，会交给index.php文件去处理，然后会返回一个处理结果，可能是登录失败，也可能是跳转到系统内部。</p>
<p>&#160; &#160; &#160; &#160;可以看到，这些数据的格式和查询字符串的格式一致，Content-Type字段值为application/x-www-form-urlencoded，这是POST提交数据的几种格式之一，POST提交数据的几种格式会在以后的文章中介绍。</p>
<p>&#160; &#160; &#160; &#160;当然，GET方法也可以用来传输数据，但是首先URL的长度受浏览器、服务器、操作系统影响，其次是GET方法提交的参数都会在地址栏中显示出来，不安全，因此涉及到大量数据、敏感数据的时候，一般采用POST方法。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>&#160; &#160; &#160; &#160;HEAD：获取报文首部。HEAD方法和GET方法很像，但服务器接收到HEAD请求时，在响应中只会返回报文首部，不会返回报文主体。常用于测试请求资源是否存在或是否被修改。</p>
<div align="center">
    {% asset_img 10-head1.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;GET请求，除了返回报文首部，还返回了主体，经浏览器解析，成为我们眼中的百度首部。</p>
<div align="center">
    {% asset_img 11-head2.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;HEAD请求，只返回首部，没有主体。</p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>&#160; &#160; &#160; &#160;OPTIONS：查询资源支持的方法。用于查询URL指定的资源支持哪些方法，资源支持哪些方法，会在响应包的Allow字段中显示。</p>
<div align="center">
    {% asset_img 12-option.jpg %}
</div>


<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>&#160; &#160; &#160; &#160;PUT：传输文件。服务器会将请求主体的内容保存到URL指定的资源位置，包含两种情况：URL指定的资源不存在和URL指定的资源存在。</p>
<div align="center">
    {% asset_img 13-put1.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;如果URL指定的资源不存在，服务器会新建一个文件，将请求主体中的内容保存到新建的文件里，响应码为201。</p>
<div align="center">
    {% asset_img 14-put2.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;如果URL指定的资源存在，服务器会重置文件内容，用请求主体中的内容覆盖原文件内容，响应码为200或204。</p>
<p>&#160; &#160; &#160; &#160;需要注意的是，PUT方法自身不带验证机制，任何人都可以执行，存在安全问题，所以网站一般不会使用PUT方法。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>&#160; &#160; &#160; &#160;DELETE：删除文件，删除URL指定的资源，和PUT相反。</p>
<div align="center">
    {% asset_img 15-delete1.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;文件删除成功，响应码为204。</p>
<div align="center">
    {% asset_img 16-delete2.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;若删除的文件不存在，响应码为404。</p>
<p>&#160; &#160; &#160; &#160;和PUT一样，DELETE方法同样不带验证机制，所以网站一般也不使用DELETE方法。</p>
<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><p>&#160; &#160; &#160; &#160;TRACE：路径追踪。主要用于诊断，让服务器将收到的请求放在响应主体中，环回给客户端，这样客户端就可以判断发出的请求是否被请求/响应链(在客户端和服务器端之间，请求可能会经过代理、网关、防火墙等应用程序)篡改。</p>
<p>&#160; &#160; &#160; &#160;TRACE请求不能带有实体的主体部分，TRACE响应的实体主体包含服务器收到的请求。</p>
<div align="center">
    {% asset_img 17-trace1.jpg %}
</div>

<p>&#160; &#160; &#160; &#160;以上都是方法没被禁用时的响应，如果方法被禁用，响应码为405。</p>
<div align="center">
    {% asset_img 18-trace2.jpg %}
</div>



<p>&#160; &#160; &#160; &#160;HTTP是可扩展的。除了使用HTTP/1.1规范中定义的方法，有的扩展还定义了一些新的方法，被称为扩展方法。</p>
<p>&#160; &#160; &#160; &#160;以下是WebDAV HTTP扩展包含的方法。</p>
<div align="center">
    {% asset_img 19-webdav.jpg %}
</div>







<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>&#160; &#160; &#160; &#160;请求方法告诉服务器要做什么，状态码则告诉客户端，服务器对请求的处理结果：是正常处理了请求，还是出现了错误。HTTP状态码被分成了以下5类。</p>
<div align="center">
    {% asset_img 20-状态码.jpg %}
</div>


<h2 id="1xx——信息提示"><a href="#1xx——信息提示" class="headerlink" title="1xx——信息提示"></a>1xx——信息提示</h2><p>&#160; &#160; &#160; &#160;1xx响应表明服务器端正在处理客户端发过来的请求。</p>
<div align="center">
    {% asset_img 21-1xx.jpg %}
</div>

<h2 id="2xx——成功"><a href="#2xx——成功" class="headerlink" title="2xx——成功"></a>2xx——成功</h2><p>&#160; &#160; &#160; &#160;2xx响应表明服务器端正常处理了客户端发过来的请求。</p>
<div align="center">
    {% asset_img 22-2xx.jpg %} 
</div>

<p>&#160; &#160; &#160; &#160;常用的有：</p>
<p>&#160; &#160; &#160; &#160;200(成功)、201(已创建)、204(无内容)、206(部分内容)</p>
<h2 id="3xx——重定向"><a href="#3xx——重定向" class="headerlink" title="3xx——重定向"></a>3xx——重定向</h2><p>&#160; &#160; &#160; &#160;3xx响应表明客户端请求的资源的位置发生了改变，要完成请求，需进一步操作。</p>
<div align="center">
    {% asset_img 23-3xx1.jpg %}

<pre><code>{% asset_img 24-3xx2.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;常用的有：301(永久移动)、302(临时移动)</p>
<h2 id="4xx——客户端错误"><a href="#4xx——客户端错误" class="headerlink" title="4xx——客户端错误"></a>4xx——客户端错误</h2><p>&#160; &#160; &#160; &#160;4xx响应表明客户端发过来的请求有问题，服务器无法处理。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/25-4xx1.jpg" class>

<pre><code>{% asset_img 26-4xx2.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;常用的有：</p>
<p>&#160; &#160; &#160; &#160;400(语法错误)、401(未认证)、403(禁止访问)、404(未找到)、405(方法禁用)</p>
<h2 id="5xx——服务器错误"><a href="#5xx——服务器错误" class="headerlink" title="5xx——服务器错误"></a>5xx——服务器错误</h2><p>&#160; &#160; &#160; &#160;5xx响应表明服务器自身出了问题，处理不了客户端发过来的请求。</p>
<div align="center">

<pre><code>{% asset_img 27-5xx1.jpg %}

{% asset_img 27-5xx2.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;常用的有：500(服务器错误)、502(网关错误)</p>
<h1 id="首部-1"><a href="#首部-1" class="headerlink" title="首部"></a>首部</h1><p>&#160; &#160; &#160; &#160;HTTP首部由多个首部字段构成，旨在向报文中添加一些通信过程中所需的重要信息。</p>
<p>&#160; &#160; &#160; &#160;从本质上来说，首部字段是名/值对，由字段名和字段值组成，中间用冒号“ : ”隔开，字段值前可包含一个空格。每一行一个首部字段，由CRLF结束行。注意，首部应该以空行(单个CRLF)结束，即使没有主体。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">首部字段名: 字段值</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;根据用途，HTTP首部字段被分为4类：通用首部、请求首部、响应首部、实体首部。</p>
<p>&#160; &#160; &#160; &#160;首部字段不一定都是HTTP/1.1规范定义的，其中，HTTP/1.1规范中定义的首部字段只有47种。下列表格中的都是HTTP/1.1规范定义的首部字段。</p>
<h2 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h2><p>&#160; &#160; &#160; &#160;请求报文和响应报文都可以使用的首部。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/28-%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8.jpg" class>
</div>


<h2 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h2><p>&#160; &#160; &#160; &#160;请求报文使用的首部。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/29-%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8.jpg" class>
</div>


<h2 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h2><p>&#160; &#160; &#160; &#160;响应报文使用的首部。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/30-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A81.jpg" class>

<pre><code>{% asset_img 31-响应首部2.jpg %}</code></pre></div>




<h2 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h2><p>&#160; &#160; &#160; &#160;实体使用的首部。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/32-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;HTTP首部除了使用HTTP/1.1规范中定义的首部字段，还会使用其他RFC中定义的首部字段，比如Cookie、Set-Cookie等。</p>
<p>&#160; &#160; &#160; &#160;大家只需要了解常用的首部字段即可，这些常用的字段我会在以后的文章中介绍。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/HTTP-HTTP%E6%8A%A5%E6%96%87/33-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>PTES | 情报搜集</title>
    <url>/PTES-%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&#160; &#160; &#160; &#160;在《PTES-渗透测试执行标准》中介绍了渗透测试的一般流程，其中简要介绍了情报搜集的目标。</p>
<p>&#160; &#160; &#160; &#160;情报搜集的目标是尽可能多的收集渗透对象的信息(网络拓扑、系统配置、安全防御措施等)，在此阶段收集的信息越多，后续阶段可使用的攻击矢量就越多。</p>
<p>&#160; &#160; &#160; &#160;因为情报搜集可以确定目标环境的各种入口点(物理、网络、人)，每多发现一个入口点，都能提高渗透成功的几率。</p>
<p>&#160; &#160; &#160; &#160;情报搜集的方法多种多样，本文主要介绍情报搜集中一些常用的方法。首先对情报搜集的方法进行分类，然后分别从Web应用、主机两个层面对情报搜集的方法进行简要介绍。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>&#160; &#160; &#160; &#160;根据是否与目标直接交互，可将情报搜集分为被动情报搜集和主动情报搜集。</p>
<h2 id="被动情报搜集"><a href="#被动情报搜集" class="headerlink" title="被动情报搜集"></a>被动情报搜集</h2><p>&#160; &#160; &#160; &#160;不与目标直接交互；利用OSINT(公开资源情报)，通过搜索引擎及其他手段从各种公开的资源中获取目标的信息。</p>
<p>&#160; &#160; &#160; &#160;常用工具和技术：Google Hacking、Shadon、Zoomeye、Whois等。</p>
<h2 id="主动情报搜集"><a href="#主动情报搜集" class="headerlink" title="主动情报搜集"></a>主动情报搜集</h2><p>&#160; &#160; &#160; &#160;与目标直接交互；通过请求响应、扫描等方式获取目标的信息，会在目标服务器留下痕迹。</p>
<h1 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h1><p>&#160; &#160; &#160; &#160;Web应用的情报搜集可以从以下几个方面着手：</p>
<h2 id="IP（IP资产）"><a href="#IP（IP资产）" class="headerlink" title="IP（IP资产）"></a>IP（IP资产）</h2><p>&#160; &#160; &#160; &#160;渗透测试往往是从Web应用开始，Web应用渗透结束，就会着手主机层面的渗透。要对主机进行渗透，首先得知道主机的IP地址。</p>
<p>&#160; &#160; &#160; &#160;对于安全服务来说，客户一般会提供详细的Web资产和主机资产，不需要我们去搜集这些信息；但传统的渗透，这些都需要我们自己去搜集。</p>
<p>&#160; &#160; &#160; &#160;获取到的IP信息，首先可用于主机层面的渗透。其次，企业一般都会有一个或多个IP段，或者运用虚拟主机技术，在一个主机上运行多个站点，所以还可用于旁站，C段。</p>
<p>&#160; &#160; &#160; &#160;可用于IP信息搜集的工具有：whois、nmap、nslookup等。</p>
<h2 id="子域名（Web资产）"><a href="#子域名（Web资产）" class="headerlink" title="子域名（Web资产）"></a>子域名（Web资产）</h2><p>&#160; &#160; &#160; &#160;很多时候，渗透测试是从一个域名开始。但一个企业往往会有多个子域名及其他相关业务，就像鹅厂有游戏，有即时通讯等等。</p>
<p>&#160; &#160; &#160; &#160;如果只关注一个域名的话，往往会少搜集到很多信息。而且主域名和子域名的关注程度和安全程度可能有所不同，通过子域名枚举，可以发现更多评估范围内的域名，探测到一些隐藏的服务，能够提高漏洞被发现的几率。</p>
<p>&#160; &#160; &#160; &#160;可用于子域名枚举的工具有：Google、Sublist3r、knockpy等。</p>
<h2 id="指纹识别（中间件资产）"><a href="#指纹识别（中间件资产）" class="headerlink" title="指纹识别（中间件资产）"></a>指纹识别（中间件资产）</h2><p>&#160; &#160; &#160; &#160;每件事物都有指纹，根据指纹，我们能得到很多有用的信息。比如，警察搜集指纹，对比指纹库就知道犯人是谁；一看手机logo就知道是什么牌子的手机。</p>
<p>&#160; &#160; &#160; &#160;同样，计算机也有指纹。通过指纹识别，我们可以判断目标系统使用了哪些组件，组件的版本等。</p>
<p>&#160; &#160; &#160; &#160;指纹识别的一种方式是查看源代码，特别是当系统使用了框架和CMS(内容管理系统)的时候。</p>
<p>&#160; &#160; &#160; &#160;框架和CMS一般都会有自己独特的图标、js文件、css文件、版权信息Powered By、标签属性值、注释等等，比如Django框架中，表单默认是带csrf_token验证的，在源代码中我们可以找到隐藏的token字段。</p>
<div align="center">
    <img src="/PTES-%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86/1-django.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;只要我们找到了指纹特征，就很容易判断系统使用的框架，然后去网上查找框架是否有漏洞可利用即可。甚至，还可以下载框架源码去做代码审计。</p>
<p>&#160; &#160; &#160; &#160;除了查看源代码，还可以通过与目标交互获取指纹。查看文件后缀，查看目录URL，查看Cookie，查看首部字段X-Powered-By和Server，查看报错页面等等。</p>
<div align="center">
    <img src="/PTES-%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86/2-%E6%8A%A5%E9%94%99.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;比如我们通过交互，发现这个页面。熟悉的校友应该知道，这是IIS的报错页面，那么操作系统很可能是Windows，因为IIS主要是搭配Windows系统使用。</p>
<p>&#160; &#160; &#160; &#160;根据这篇文章，我们可以先存疑，该系统存不存在HTTP.sys远程代码执行漏洞。另外，系统存不存在IIS解析漏洞，解析漏洞又常与文件上传漏洞配合使用，要利用解析漏洞，就要先找到系统的上传漏洞。然后IIS有没有启用WebDAV呢？WebDAV中的COPY/MOVE方法可是不安全的，和PUT方法搭配口味更佳~</p>
<p>&#160; &#160; &#160; &#160;哇，感觉世界都是我的了！</p>
<p>&#160; &#160; &#160; &#160;总之，指纹识别的目标是：What、Version</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">什么服务器，服务器版本</span><br><span class="line">什么数据库，数据库版本</span><br><span class="line">什么OS，OS版本</span><br><span class="line">什么语言，语言版本</span><br><span class="line">什么框架，框架版本</span><br><span class="line">什么组件，组件版本</span><br><span class="line">可用于指纹识别的工具有：whatweb、httprint、CMSmap、在线识别等。</span><br></pre></td></tr></table></figure>

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>&#160; &#160; &#160; &#160;查看源代码还有可能获取到其他敏感信息。</p>
<p>&#160; &#160; &#160; &#160;目前绝大多数的网页由3部分组成：HTML(结构)、CSS(样式)、JavaScript(动作)，浏览器会将代码解析成对我们友好的页面，但很多细节并不会在页面中展示给我们，比如：隐藏的表单、JavaScript代码等，因此对源代码的审计是很有必要的。</p>
<p>&#160; &#160; &#160; &#160;很多校友对源代码的审计可能停留在html文件中，但js文件也需要审计。</p>
<p>&#160; &#160; &#160; &#160;一次工作，在js文件中找到了一个积分接口，但页面没有入口。我直接构造url，发起请求，个人账户的积分蹭蹭往上涨。与客户开发人员交流后，得知积分要消费才会涨，积分也可以兑换东西。这个时候就可以将其定义为漏洞了。</p>
<h2 id="目录-文件"><a href="#目录-文件" class="headerlink" title="目录/文件"></a>目录/文件</h2><p>&#160; &#160; &#160; &#160;在摸清目标资产情况（IP资产、Web资产、中间件资产）之后，我们就可以摸索Web应用的结构了。</p>
<p>&#160; &#160; &#160; &#160;在测试大型的系统时，我个人的习惯是先查看一下Web应用整体的功能点和链接结构（接口），然后保证所有的功能点和接口都测试到就行。</p>
<p>&#160; &#160; &#160; &#160;因为系统不可能每个链接结构都不一样，一般都会存在复用的情况，除非功能不同。比如充话费，共用一个接口，充值金额不同只要修改接口中的话费id即可。</p>
<p>&#160; &#160; &#160; &#160;在测试的时候，我只需要测试其中一种金额就行了，或者测试两种，观察一下其中的规律，看有没有漏洞存在，可千万别1-100块都试一下。如果一顿操作猛如虎，将系统中所有链接都一个个去点击抓包分析，效率往往会低很多。</p>
<p>&#160; &#160; &#160; &#160;如何查看链接结构？我们可以把鼠标移动到要点击的链接上，浏览器下方会显示出来，或者点击链接，查看浏览器地址栏中的URL，或者抓包，这些方法都可以。</p>
<div align="center">
    <img src="/PTES-%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86/3-%E6%9F%A5%E7%9C%8Burl.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;以上是摸索Web应用结构的一种情况，能提高我们渗透的效率。还有一种情况，就是查看特殊的目录和文件。</p>
<p>&#160; &#160; &#160; &#160;何为特殊的目录和文件？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">网站后台：/admin、/manage、/wp-login.php 等</span><br><span class="line">Web管理入口：Tomcat Web管理页面、phpmyadmin管理页面 等</span><br><span class="line">探针类文件：phpinfo.php 等</span><br><span class="line">备份文件：网站源码、数据库、配置 等</span><br><span class="line">配置文件：数据库、服务器 等</span><br><span class="line">robots.txt</span><br><span class="line">其他可造成信息泄露的文件</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;要查看这些目录和文件，有两种方法：一是手工构造，利用自身经验以及之前搜集到的信息，构造路径，查看目录和文件是否存在；二是利用字典跑出来。搜集这些目录和文件有什么用，应该不用我说明了吧？</p>
<p>&#160; &#160; &#160; &#160;可用于目录/文件搜集的工具有：Burpsuite、DirBuster、google等。</p>
<h2 id="邮箱-电话-工号-…"><a href="#邮箱-电话-工号-…" class="headerlink" title="邮箱/电话/工号/…"></a>邮箱/电话/工号/…</h2><p>&#160; &#160; &#160; &#160;几乎所有的网站都存在登录功能。要想登录系统，两种办法：一是利用其他漏洞登录，二是老老实实输入账号密码。</p>
<p>&#160; &#160; &#160; &#160;第二种方法也包含两种情况：暴力破解、明确获取到账号密码，这都涉及到邮箱/电话/工号等信息的搜集。</p>
<p>&#160; &#160; &#160; &#160;如果明确获取到了账号密码，这当然是幸运的；如果没有明确获取到账号密码，我们也可以根据搜集到的邮箱/电话/工号等信息，去发现命名规律，然后生成字典去爆破。</p>
<p>&#160; &#160; &#160; &#160;去年在给联通还是电信某个系统测试的时候，登录页面明确提示使用工号登录，查看系统相关源码，没有发现工号的踪影。我在网上查了一下，工号是4位数，然后利用登录页面的用户枚举漏洞，使用burpsuite的Intruder模块，从1111-9999中获取到了几个系统存在的账号，然后利用字典爆破出了密码，使用的是弱密码，可能是测试账号忘记删除了。如果不仔细搜集信息，使用字母字典或者不是4位数的数字字典，那可能永远都跑不出账号。</p>
<p>&#160; &#160; &#160; &#160;可用于邮箱信息收集的工具有：whois、The Harvester等。</p>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>&#160; &#160; &#160; &#160;作为全球最大的“同性社交”网站，github包含了海量的信息。这些信息中，不乏大量的“个人社交”信息。</p>
<div align="center">
    <img src="/PTES-%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86/4-github.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;鲁迅说过：“朋友多了路好走”。当你无路可走的时候，不妨出来交交朋友。像上面的截图，用户名、密码、IP地址、端口、数据库名直接告诉你，都不需要去SQL注入，一条明路就这么出现了。</p>
<p>&#160; &#160; &#160; &#160;当然，除了github，还有其他“社交”网站：gitee、coding等。</p>
<h1 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h1><p>&#160; &#160; &#160; &#160;相对Web应用，主机层面主要关注端口开放情况以及端口banner。</p>
<p>&#160; &#160; &#160; &#160;服务器通过不同端口向用户提供不同的服务，服务器就像一座房子，而端口就是一扇扇门，通过门进出房间（请求与响应），不同的门对应不同的房间。</p>
<p>&#160; &#160; &#160; &#160;每多开放一个端口，就多开一扇门，小偷打开门进入房子的成功率就高一分。当然，小偷需要开锁才能打开门，该用什么方式开锁，取决于锁的种类以及锁的安全级别，这些都能在端口号和端口banner中获取。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>&#160; &#160; &#160; &#160;每台服务器都有65536个端口，端口号范围：0—65535。不同的端口对应不同的服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FTP : 21</span><br><span class="line">SNMP : 161</span><br><span class="line">SMB : 445</span><br><span class="line">rsync : 873</span><br><span class="line">redis : 6379</span><br><span class="line">memcache : 11211</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;有一定基础的校友看到这些端口，应该能明白我想表达什么：FTP匿名登录、SNMP弱口令、给我哭、未授权、未授权、DRDOS。</p>
<p>&#160; &#160; &#160; &#160;设想一下，你在给客户测试准备上线的管理系统，你测试了半个月，Web应用竟然没任何问题。你：开发人员真棒，上线吧。结果上线5分钟，挂马2000个，检查发现上面那些端口服务器都开放了且都是默认配置。根据《网络安全法》，你可能需要喝几杯茶。</p>
<p>&#160; &#160; &#160; &#160;简单的举例，大家应该能明白全面搜集信息的重要性，这也是我将情报搜集分Web应用和主机两个层面的原因，主机端口扫描能帮助我们发现更多可行的攻击途径。当然，端口漏洞远远不止这么点，需要靠校友们不断的去储备知识和积累经验。</p>
<p>&#160; &#160; &#160; &#160;可用于端口扫描的工具：nmap、nessus、shodan、censys.io等。</p>
<h2 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h2><p>&#160; &#160; &#160; &#160;通常情况下，端口扫描不仅能获取到服务器的端口开放情况，还能获取到端口banner信息。</p>
<p>&#160; &#160; &#160; &#160;通过banner信息，可以获取到服务器操作系统以及运行在其开放端口的服务的信息，包括正在运行的应用程序以及操作系统的版本。</p>
<p>&#160; &#160; &#160; &#160;获取到版本有什么用呢？这就要借助互联网的力量了。互联网上有各种信息，漏洞信息也不例外，特别是各大安全站点，往往会有漏洞的详细信息，poc、exploit等。</p>
<p>&#160; &#160; &#160; &#160;获取到版本信息后，我们可以在网上查询该版本的软件和操作系统是否有已公布的漏洞，是否有poc和exploit，进而去验证和利用漏洞。</p>
<p>&#160; &#160; &#160; &#160;可用于banner获取的工具：telnet、nmap、netcat、shodan、censys.io等。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;情报搜集的方法和技术远远不止这些，一篇文章是介绍不完的。这里我只是简单的介绍情报搜集的一些思路，起到一个抛砖引玉的效果，希望校友们能够发散思维，形成自己的一套搜集方案。</p>
<p>&#160; &#160; &#160; &#160;篇幅问题，细节不再深究，后续我再一个一个给大家讲解。不要小看情报搜集，组合发散延伸，会让你在渗透后续阶段如虎添翼。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/PTES-%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86/5-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>情报搜集</tag>
      </tags>
  </entry>
  <entry>
    <title>PTES | 渗透测试执行标准</title>
    <url>/PTES-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<p>&#160; &#160; &#160; &#160;“入门渗透测试，首先需要了解渗透测试的流程、步骤与方法。尽管渗透目标的环境各不相同，但依然可以用一些标准化的方法体系进行规范和限制。”</p>
<div align="center">
    <img src="/PTES-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/1-%E5%A6%82%E6%9D%A5%E7%A5%9E%E6%8E%8C.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;目前渗透测试方法体系标准比较流行的有5个，其中PTES渗透测试执行标准得到了安全业界的普遍认同，它具体包括以下7个阶段。</p>
<div align="center">
    <img src="/PTES-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/2-7%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg" class>
</div>







<h1 id="前期交互阶段"><a href="#前期交互阶段" class="headerlink" title="前期交互阶段"></a>前期交互阶段</h1><p>&#160; &#160; &#160; &#160;前期交互阶段要做的事主要有以下几件：</p>
<p>&#160; &#160; &#160; &#160;介绍和解释可用的工具和技术，根据客户需求为客户提供量身定制的测试方案。可用于渗透测试的工具和技术有很多，但客户环境不一定支持，比如设备老旧，不能使用工具进行高强度的扫描行为；或者白天业务量大，只能在凌晨一两点才能测试；再或者不能进行弱口令扫描，账号锁定后会对业务产生影响等等，这些都需要事先沟通好，以免测试对客户生产环境造成影响。</p>
<p>&#160; &#160; &#160; &#160;确定项目范围，项目范围圈出了要测试的内容。我们只能对已授权的资产进行测试，未授权的资产不能进行任何测试。</p>
<p>&#160; &#160; &#160; &#160;确定周期，起始和终止时间。根据测试内容，评估所需要花的时间。一般建议多填充20%，以防测试因各种因素中断，可以拿这20%的时间作为缓冲。</p>
<p>&#160; &#160; &#160; &#160;前期交互阶段参与的一般是销售和项目经理，他们与客户达成协议后，客户将需要测试的资产交给项目经理，再由项目经理分发给渗透人员执行。但有时客户会直接和渗透人员对接，特定是在长期项目中，这个时候渗透人员也会参与到这个阶段。</p>
<h1 id="情报搜集阶段"><a href="#情报搜集阶段" class="headerlink" title="情报搜集阶段"></a>情报搜集阶段</h1><p>&#160; &#160; &#160; &#160;情报搜集阶段的目标是尽可能多的收集渗透对象的信息（网络拓扑、系统配置、安全防御措施等），在此阶段收集的信息越多，后续阶段可使用的攻击矢量就越多。因为情报搜集可以确定目标环境的各种入口点（物理、网络、人），每多发现一个入口点，都能提高渗透成功的几率。</p>
<p>&#160; &#160; &#160; &#160;和传统渗透不同的是，安全服务有时候仅仅只是针对一个功能进行测试，所以不一定每次都需要收集目标的信息，或者只需要收集一部分信息；但如果是对一个系统进行渗透，还是要尽可能多的收集目标的信息。</p>
<h1 id="威胁建模阶段"><a href="#威胁建模阶段" class="headerlink" title="威胁建模阶段"></a>威胁建模阶段</h1><p>&#160; &#160; &#160; &#160;利用上一阶段获取到的信息进行威胁建模和攻击规划。</p>
<p>&#160; &#160; &#160; &#160;威胁建模；利用获取到的信息来标识目标组织可能存在的漏洞与缺陷。威胁建模有两个关键要素：资产分析和威胁分析。识别主要和次要资产并对其进行分类，并根据资产识别其可能存在的威胁。比如看到28017端口我们要想到是否存在mongodb未授权访问，看到21端口我们要想到是否存在ftp匿名登录等等。</p>
<p>&#160; &#160; &#160; &#160;攻击规划；根据威胁模型确定下一步需要搜集的信息和攻击方法。威胁模型建立后，可行的攻击矢量已基本确定，接下来要做的就是一个一个验证其是否可行，在这个过程中依然会伴随着信息的收集以及威胁模型的调整。</p>
<h1 id="漏洞分析阶段"><a href="#漏洞分析阶段" class="headerlink" title="漏洞分析阶段"></a>漏洞分析阶段</h1><p>&#160; &#160; &#160; &#160;漏洞分析是一个发现系统和应用程序中的漏洞的过程。这些漏洞可能包括主机和服务配置错误，或者不安全的应用程序设计。虽然查找漏洞的过程各不相同，并且高度依赖于所测试的特定组件，但一些关键原则适用于该过程。</p>
<p>&#160; &#160; &#160; &#160;在进行任何类型的漏洞分析时，测试人员应适当地确定适用深度和广度的测试范围，以满足所需结果的目标和要求。传统的渗透是能通过一个漏洞拿到服务器最高权限就行，因此其重点是发现一个可利用的漏洞。但安全服务要求我们尽可能多的发现目标存在的漏洞，以此来保证系统的安全，而且很多时候只要证明漏洞存在即可，不需要再进行漏洞利用。两者的区别就相当于点和面，广度和深度均有所不同，具体执行尺度需要根据客户需求来定。</p>
<p>&#160; &#160; &#160; &#160;有些漏洞的验证，我们可以通过抓包改包很轻易的实现，但有些漏洞，验证的步骤很繁琐，则需要编写特定的概念验证（POC）来验证漏洞，这就要求测试人员有一定的开发能力。</p>
<h1 id="漏洞攻击阶段"><a href="#漏洞攻击阶段" class="headerlink" title="漏洞攻击阶段"></a>漏洞攻击阶段</h1><p>&#160; &#160; &#160; &#160;在验证漏洞存在后，接下来就是利用发现的漏洞对目标进行攻击了。漏洞攻击阶段侧重于通过绕过安全限制来建立对系统或资源的访问，实现精准打击，确定目标的主要切入点和高价值目标资产。</p>
<p>&#160; &#160; &#160; &#160;为实现系统安全，系统往往都会采用诸多技术来进行防御，如反病毒（IPS、IDS、WAF、……）、编码、加密、白名单等，在渗透期间，则需要混淆有效载荷来绕过这些安全限制，以达到成功攻击的目的。很多情况下，互联网上有很多公开的漏洞利用，可直接拿来使用，但对于一些特殊情况，则需要我们根据实际情况来量身定制有效载荷(payload)和漏洞利用(exploit)。</p>
<h1 id="后渗透攻击阶段"><a href="#后渗透攻击阶段" class="headerlink" title="后渗透攻击阶段"></a>后渗透攻击阶段</h1><p>&#160; &#160; &#160; &#160;后渗透攻击，顾名思义就是漏洞利用成功后的攻击，即拿到系统权限后的后续操作。后渗透攻击阶段的操作，可分为两种：权限维持和内网渗透。</p>
<p>&#160; &#160; &#160; &#160;权限维持——提升权限及保持对系统的访问。系统最高权限是我们向往的ONEPIECE，如果漏洞利用阶段得到的权限不是系统最高权限，我们应该继续寻找并利用漏洞进行提权。同时为了保持对系统的访问权限，我们应该留下后门（木马文件等）并隐藏自己（清除日志、隐藏文件等）。</p>
<div align="center">
    <img src="/PTES-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/3-onepicec.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;内网渗透——利用获取到的服务器对其所在的内网环境进行渗透。内网环境往往要比外网环境有趣，我们可以利用获取到的服务器进一步获取目标组织的敏感信息。</p>
<h1 id="报告阶段"><a href="#报告阶段" class="headerlink" title="报告阶段"></a>报告阶段</h1><p>&#160; &#160; &#160; &#160;渗透测试的最后一步便是报告输出。客户不会关心渗透的过程到底是怎样，他们要的只有结果，因此一份好的报告尤其重要。好的报告至少要包括以下两个主要部分，以便向客户传达测试的目标、方法和结果。</p>
<p>&#160; &#160; &#160; &#160;执行概要。这个部分向客户传达测试的背景和测试的结果。测试的背景主要是介绍测试的总体目的，测试过程中会用到的技术，相关风险及对策。测试的结果主要是将渗透测试期间发现的问题进行简要总结，并以统计或图形等易于阅读的形式进行呈现。然后根据结果，对系统进行风险等级评估并解释总体风险等级、概况和分数，最后再给出解决途径。</p>
<div align="center">
    <img src="/PTES-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/4-%E9%A3%8E%E9%99%A9%E7%AD%89%E7%BA%A7.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;技术报告。这个部分主要是向客户传达测试的技术细节，详细描述测试发现的问题、攻击路径、影响和修复建议等。一方面是为了让客户更好的理解问题所在，将漏洞进行整改，另一方面是方便后续漏洞复查，形成矩阵跟踪闭环。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/PTES-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E6%A0%87%E5%87%86/5-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>信息收集之js文件</title>
    <url>/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8Bjs%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;JavaScript已经成为现代Web浏览器开发中最普遍的技术之一。之前在《PTES-信息收集》中讲到源代码审计也可能获取到一些敏感信息，但有的测试人员只审计html源代码，而忽略审计js文件里的源代码，今天我们就来讲一讲审计js文件都能获取到哪些信息。</p>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>&emsp;&emsp;通过审计js文件源代码能获取到的信息，我个人将其分为以下四类：敏感信息、业务逻辑、加密算法、Ajax请求。</p>
<h2 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h2><p>&emsp;&emsp;审计js文件最直观的就是很有可能获取到账号密码、配置等敏感信息。</p>
<p>&emsp;&emsp;HTML定义页面结构，CSS定义装修样式，而JavaScript定义前端工作内容，主要是监听事件执行动作，比如逻辑判断，亦或是向服务器发送请求等等。而要正确执行这些动作，通常都会进行一些简单的配置。</p>
<p>&emsp;&emsp;最常见的配置就是设置网站根路径，不过也经常遇到直接在js文件里配置账号密码的情况；更有甚者，有的开发人员直接在js文件里定义SQL语句，然后由前端发送到服务器执行。这不仅泄露了数据库信息，也提高了SQL注入漏洞攻击的风险。</p>
<p>&emsp;&emsp;以上是获取敏感信息的一种情况，还有一种情况就是注释。</p>
<p>&emsp;&emsp;为了更好的维护代码、调试代码，我们经常在源码中见到各种注释。比如为了方便调试，直接把账号密码写在Javascript代码中，调试完后，只是把这条语句注释掉而非删掉；有时候系统更迭，推出一些新的接口，开发人员把老接口注释掉使用新的接口，但服务器端并没有把老接口关掉等等。</p>
<p>&emsp;&emsp;以上情况不仅让我们搜集到了更多目标信息，也增加了系统攻击面，只能说：这些开发人员真他娘的是个人才。</p>
<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><p>&emsp;&emsp;除了能获取到敏感信息，审计js文件还可以获取到Web系统的一些业务逻辑。</p>
<p>&emsp;&emsp;说到业务逻辑，就要牵扯到前端校验。有些系统只做了前端校验，只要响应包满足条件，就会执行下一步操作，服务器端不会再进一步检验接下来的请求是否有问题，我们只要修改响应包就可以绕过检测。</p>
<p>&emsp;&emsp;比如输入错误的账号密码，响应false，要求重新输入账号密码；我们把响应包拦截，把false改成true，前端检测到true，认为账号密码正确，发送跳转到系统内部的请求，而服务器没有再校验请求是否有问题，将系统内部页面响应给前端。</p>
<p>&emsp;&emsp;要绕过前端校验，像0/1、true/false这种很容易就能猜到该怎么修改，但有些系统可能有十多个响应码，或者响应码有多位，如果我们耐着性子一个一个去试，时间成本会很大。</p>
<p>&emsp;&emsp;比如0是用户名错误，1是密码错误，2是验证码错误，9999是登陆成功，如果我们从0开始，一个一个去试，说真的还不一定能试出来。除非先输入正确的账号密码得到正确的响应码，然后输入错误的账号密码，再用之前得到的正确响应码替换错误的响应码，尝试看是否存在前端校验的问题。</p>
<p>&emsp;&emsp;问题是：如果是安全服务，客户还有可能提供账号密码，但攻防演练、挖洞一般都是靠自己白手起家，哪里有什么账号密码给你。而前端业务逻辑通常都由js实现，基本都可以通过代码审计来确定如何构造响应包来尝试绕过前端校验。我只想说：信息收集真的很重要。</p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>&emsp;&emsp;审计代码能获取到的第三类信息就是加密算法。在当今的大环境下，企业越来越重视安全，运用了各种防护手段来提高系统的安全系数，提高攻击者的攻击成本，其中就有加密机制。</p>
<p>&emsp;&emsp;可能很多测试人员在测试的时候，抓包发现参数值都是加密的，就这么放过了。但这种前端加密都是可以在js中找到加密算法的，要么在html文件的js中，要么包含在js文件中。</p>
<p>&emsp;&emsp;当然我们也可以不需要知道加密算法到底是怎么样的，直接输入测试的明文Payload，系统自然会利用加密算法输出对应的加密数据。这个Payload不行，我们再输入下一个明文Payload去测试。</p>
<p>&emsp;&emsp;以上的方式时间成本会增加很多，而且有时候系统会先检测输入的数据是否含有非法字符，没有非法字符才会加密发送到服务器端。而只要我们找到了对应的加密算法，就可以手工构造或者编写脚本批量生成我们想要的加密数据，进而去测试系统是否存在漏洞。</p>
<p>&emsp;&emsp;据目前工作经历来看，涉及到加密的参数，存在漏洞的几率要高很多。因为前端加密后，后端必须解密才能使用。但很多时候，系统的安全检测只在请求传过来的时候，加密时没有检测到非法字符就绕过了检测，后端解密之后就可以肆意横行。</p>
<h2 id="Ajax请求"><a href="#Ajax请求" class="headerlink" title="Ajax请求"></a>Ajax请求</h2><p>&emsp;&emsp;审计js文件能获取到的信息还有Ajax请求，也是漏洞重灾区。而Ajax请求的调用通常很隐蔽，且Ajax请求的触发条件无规律，很容易被遗漏或忽略。</p>
<p>&emsp;&emsp;Ajax请求通常是被各个事件触发调用，而这些事件的触发往往需要满足一定条件。但很多时候，即便事件触发条件未满足，我们去构造Ajax请求的数据包发送给服务器端，依然可以得到服务器的响应。</p>
<p>&emsp;&emsp;服务器访问控制不当，并没有去检测用户是否是通过正常业务逻辑发送Ajax请求，也没有去检测用户是否有操作权限。服务器认为客户端发过来的请求都是正确的，这又要提一下安全的本质：一切输入都是不安全的。而且每一个Ajax请求都对应一个接口，这又增加了攻击面，每个请求都可能形成独立的攻击过程。</p>
<p>&emsp;&emsp;举个真实案例：修改密码，先要通过短信验证码校验才能修改新密码。只有管理员才能修改密码，修改密码的Ajax请求由修改密码功能调用，普通用户没有这个功能。(某些原因，没有截图，意淫一下吧)</p>
<p>&emsp;&emsp;开发人员认为所有的用户都会按照系统业务逻辑一步一步触发请求，先点击发送验证码，然后填写验证码进行校验，通过校验后跳转到修改密码的页面，输入新密码，最后修改成功。而且只有管理员有这个功能页面。</p>
<p>&emsp;&emsp;但通过代码审计，直接在js文件中找到了修改密码的Ajax请求，请求参数只有新密码。现在我们已经找到了修改密码的请求，那么我们可以跳过前面一系列的校验和请求，只需要构造出修改密码请求，就可以修改密码。</p>
<p>&emsp;&emsp;而且这个Ajax请求是写在js文件里的，系统并不会因为用户权限的不同而调用不同的js文件，所以普通用户也能够查到到对应的js代码，不存在管理员一说。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;本文简单讲述了审计js文件源代码能获取到的四类信息：敏感信息、业务逻辑、加密算法、Ajax请求。</p>
<p>&emsp;&emsp;当然，这也仅仅是我个人的归类，审计代码能获取到的信息远不止这些，需要大家去深入挖掘，我纯碎起一个抛砖引玉的作用。</p>
<p>&emsp;&emsp;忙里偷闲，差不多半年才写了一篇文章。这波行动差不多要结束了，接下来就是国庆重保。国庆重保后不出意外的话应该，可能，也许会稍微轻松一点，争取一个月能写篇文章吧。感谢大家的关注！</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&emsp;&emsp;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8Bjs%E6%96%87%E4%BB%B6/1-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日命令 | cp</title>
    <url>/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/</url>
    <content><![CDATA[<h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><p>&#160; &#160; &#160; &#160;上回我们介绍了文件和目录的创建，今天我们来介绍一下文件和目录的复制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp——复制文件或目录</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/1-cp.jpg" class>
</div>









<h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [选项] 参数1 参数2</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;以上是cp命令的语法，可以看到cp命令在使用时必须提供两个参数。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&#160; &#160; &#160; &#160;参数1代表源文件，即要复制哪个文件或目录；参数2代表目标文件，即复制到哪个文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/2-cp.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;复制docker.sh，只提供一个参数，系统提示缺少一个目标文件。提供两个参数后，成功将docker.sh复制到docker1.sh。</p>
<p>&#160; &#160; &#160; &#160;cp命令有三种主要的操作模式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">文件复制到文件</span><br><span class="line">文件复制到目录</span><br><span class="line">目录复制到目录</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;复制docker.sh到docker1.sh就是第一种操作模式。在执行cp命令时，如果目标文件不存在，则会创建目标文件；如果目标文件已经存在，默认会用源文件覆盖目标文件。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/3-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;首先新建一个old_file文件，然后复制到new_file文件。在执行cp命令之前，new_file文件是不存在的，于是系统生成了new_file。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/4-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;这个时候，new_file文件和old_file文件都是空白文件，cat命令可用来查看文件内容，后面的文章再给大家介绍。</p>
<p>&#160; &#160; &#160; &#160;然后在old_file文件中添加一句话，保存后再执行cp命令，查看new_file文件，发现new_file文件的内容已经被old_file文件所覆盖。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/5-cp.jpg" class>
</div>



<p>&#160; &#160; &#160; &#160;以上是文件复制到文件的操作模式，接下来介绍一下文件复制到目录的操作模式。</p>
<p>&#160; &#160; &#160; &#160;文件到文件和文件到目录，两种操作模式最大的区别是文件到目录的模式可以同时包含多个源文件，而文件到文件的模式只允许一个源文件，其他并没有什么区别。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/6-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，文件复制到目录的操作模式下，系统没有报错；但文件复制到文件的操作模式，提供三个参数，系统报错，提示new_file不是目录。</p>
<p>&#160; &#160; &#160; &#160;最后介绍目录复制到目录的操作模式。这种模式，可以同时复制文件和目录，但是在复制目录的时候，必须添加“-r”选项，cp命令才会将源目录复制到目标目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/7-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;添加“-r”选项前，系统提示没有提供“-r”选项，省略了目录的复制，只复制了docker.sh文件。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/8-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;添加“-r”选项后，成功将目录复制到了目标目录。也可以使用“-R”选项，效果和“-r”选项一样。</p>
<p>&#160; &#160; &#160; &#160;需要注意的是，在文件到目录、目录到目录的操作模式中，目标文件指定的目录必须存在，cp命令并不会为我们创建目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/9-cp.jpg" class>
</div>


<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>&#160; &#160; &#160; &#160;cp命令选项有点多，这里我挑几个比较常用的选项给大家介绍一下，其余的大家可以查阅相关资料来进行学习。</p>
<p>&#160; &#160; &#160; &#160;首先是“-i”选项。在执行cp命令时，如果目标文件存在，则默认用源文件覆盖目标文件。添加“-i”选项之后，系统会在覆盖之前询问我们。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -i 源文件 目标文件</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;首先我们新建old_file文件，复制到new_file文件，然后在old_file文件中添加一句话。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/10-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;此时new_file是没有内容的，我们再执行cp命令，这个时候添加“-i”选项。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/11-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;添加“-i”选项后，系统会询问我们是否覆盖目标文件。只有我们输入“y“的时候(Y、yes、1、Yes等也可以，能代表”是“一般都行，通常都是使用y)，系统才会覆盖，输入其他任何字符都会被认为不覆盖。</p>
<p>&#160; &#160; &#160; &#160;添加”-i“选项后，目标文件存在时，系统都会询问我们。如果有大量的目标文件存在，那我们输入答案都要费很大功夫，特别是当我们只想复制不存在的目标文件时，这个选项显然不能很好满足我们的需求。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/12-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;为此，Linux为我们提供了”-n“选项。添加这个选项之后，系统就默认不覆盖已经存在的目标文件，可以理解为只复制不存在的目标文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -n 源文件 目标文件</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/13-cp.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;新建old_file和new_file文件，然后修改old_file文件，在执行cp命令时添加”-n“选项，查看new_file文件，依然是空白文件，说明没有用old_file覆盖new_file。</p>
<p>&#160; &#160; &#160; &#160;除了可以选择不覆盖已经存在的目标文件，还可以选择强制复制文件，不管目标文件是否存在，这通过”-f“选项来实现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -f 源文件 目标文件</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/14-cp.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;另外，还可以选择只有源文件的时间属性比目标文件新或目标文件不存在的时候才复制，通过”-u“选项来实现，相当于更新。</p>
<p>&#160; &#160; &#160; &#160;举个例子。我在桌面上新建了一个工作周报，记录了我这周的工作内容，然后我想把这个文档复制到某个文件夹内，但这个文件夹里已经存在了上周的工作周报，这个时候我肯定要拿桌面的工作周报覆盖文件夹里的工作周报才行，反之，如果文件夹的工作周报比桌面的工作周报新，则不覆盖。”-u“选项就可以执行这个工作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -u 源文件 目标文件</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/15-cp.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;首先将new_file文件更新，这个时候new_file文件相对old_file文件要新一些，此时添加“-u”选项复制一下，发现new_file文件内容没有改变。</p>
<p>&#160; &#160; &#160; &#160;以上选项的复制都是不包含属性的，比如时间、权限等。如果想连同源文件的属性也复制过去，就必须使用“-p”选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -p 源文件 目标文件</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/16-cp.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;首先用stat命令查看old_file和new_file的属性，然后添加“-p”选项复制，发现new_file文件的访问时间和修改时间不是当前时间，而是old_file文件的访问时间和修改时间。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/17-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;文件权限也被复制到new_file文件。chmod命令用来修改文件和目录的权限，后面的文章会详细讲解。</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">    cp [选项] 源文件 目标文件</span><br><span class="line">用途：复制文件或目录</span><br><span class="line">选项：</span><br><span class="line">    -i————覆盖前的交互提示</span><br><span class="line">    -n————不覆盖现有文件</span><br><span class="line">    -f————强制复制</span><br><span class="line">    -u————更新</span><br><span class="line">    -p————保留源文件的属性</span><br><span class="line">    -r、-R————递归复制目录</span><br><span class="line">参数：源文件、目标文件（绝对地址和相对地址都可以）</span><br><span class="line">其他：</span><br><span class="line">    三种操作模式：文件到文件、文件到目录、目录到目录</span><br><span class="line">    文件到文件的操作模式，只允许有两个参数</span><br><span class="line">    目录到目录的操作模式，必须添加“-r”或“-R”选项</span><br><span class="line">    文件到目录、目录到目录的操作模式，目录必须存在</span><br></pre></td></tr></table></figure>








<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-cp/18-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>





]]></content>
      <categories>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS-简介(1)</title>
    <url>/XSS-%E7%AE%80%E4%BB%8B-1/</url>
    <content><![CDATA[<h1 id="XSS是什么"><a href="#XSS是什么" class="headerlink" title="XSS是什么"></a>XSS是什么</h1><p>&emsp;&emsp;跨站脚本（Cross-Site Script），由于和层叠样式表CSS缩写一样，为避免混淆，因而缩写成XSS。</p>
<p>&emsp;&emsp;XSS是一种常见的Web安全漏洞。由于Web应用程序对用户输入检测不严，导致攻击者可以把恶意代码（通常是HTML和JavaScript）注入到网页中。当其他用户访问时，恶意代码就会被执行。通常被利用发起Cookie窃取、会话劫持、钓鱼等攻击。</p>
<h1 id="XSS为何如此普遍"><a href="#XSS为何如此普遍" class="headerlink" title="XSS为何如此普遍"></a>XSS为何如此普遍</h1><p>&emsp;&emsp;在工作中不难发现，几乎所有测试任务或多或少都会发现XSS的存在。为何XSS会如此普遍？都是由哪些因素造成的？</p>
<p>&emsp;&emsp;首先Web浏览器本身的设计是不安全的。浏览器只会执行程序，它并不会去判断程序和数据是否恶意；其次是输入输出的交互过程中，没有足够完善的安全防护机制；然后触发XSS的方式简单丰富，只要注入恶意代码即可；最后是开发人员的水平不高和意识不足所导致。</p>
<p>&emsp;&emsp;下图为2013和2017的OWASP TOP 10，尽管XSS从第3掉到第7，但依然是十大Web安全漏洞，这也能够看出XSS漏洞的普遍和流行。</p>
<div align="center">
    
</div>




<h1 id="XSS有什么危害"><a href="#XSS有什么危害" class="headerlink" title="XSS有什么危害"></a>XSS有什么危害</h1><p>&emsp;&emsp;尽管XSS如此普遍，但XSS也就能“弹个对话框而已”，能有什么危害呢？在工作中我就被开发人员这样质疑过（因为我发现的漏洞基本存在于他写的代码中，手动滑稽）。</p>
<p>&emsp;&emsp;这里要强调的是，漏洞的验证和利用是两码事。为了验证XSS漏洞是否存在，我们通常采用弹框的方式，结果显而易见。弹框只为证明漏洞存在，证明漏洞存在后才是真正利用阶段。</p>
<p>&emsp;&emsp;漏洞能利用到什么程度，能产生多大危害，取决于你如何编写注入的恶意代码。比如写入一个a标签，点击后跳转到钓鱼网站；又比如在留言处写段获取Cookie的代码，当系统管理员去查看的时候，就将管理员的会话信息返回，这样我们就能利用这个会话信息去登录系统。</p>
<p>&emsp;&emsp;XSS通常被利用于Cookie窃取、会话劫持、钓鱼，也可以获取客户端信息，控制受害者浏览器执行其他操作。当然它的危害远不止这些，简单来讲，一是能获取用户的信息，二是能操作用户的设备。所以千万不要被弹框给欺骗，XSS的危害没有你想象中的那么简单。</p>
<h1 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h1><p>&emsp;&emsp;根据特性和利用手法，XSS主要分为以下三种：反射型XSS、存储型XSS、DOM型XSS。</p>
<p>&emsp;&emsp;反射型XSS也被叫做非持久型XSS、参数型XSS，是三种XSS中最常见的一种。</p>
<p>&emsp;&emsp;对于反射型XSS的利用，攻击者一般是构造一个包含恶意代码的URL，然后通过留言、邮件或其他途径发送给受害者。当受害者点击时，恶意代码就会被执行。正因为只有在用户点击时才会触发，且只执行一次，所以才被称为非持久型、反射型。</p>
<p>&emsp;&emsp;存储型XSS，也叫做持久型XSS。和反射型XSS不一样的是，存储型XSS不需要受害者去点击什么。攻击者事先将恶意代码存储到了服务器，每当受害者访问包含恶意代码的页面，恶意代码就会被执行。</p>
<p>&emsp;&emsp;存储型XSS一般出现在留言、评论、修改个人信息等与数据库存储相关的地方，而反射型XSS出现在其他交互的地方，比如搜索、登录等。</p>
<p>&emsp;&emsp;反射型XSS和存储型XSS都会和服务器产生交互，恶意代码由服务器端通过响应包返回给客户端；而DOM型XSS不会和服务器产生交互，恶意代码由前端的JavaScript处理。</p>
<p>&emsp;&emsp;三种类型的XSS简单介绍到这里，大家先在心里留下反射型XSS、存储型XSS以及DOM型XSS的概念，后续我会通过实战的方式，更直观的展示三者之间的区别。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/XSS-%E7%AE%80%E4%BB%8B-1/2-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>每日命令 | ls</title>
    <url>/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/</url>
    <content><![CDATA[<h1 id="每日命令系列导语"><a href="#每日命令系列导语" class="headerlink" title="每日命令系列导语"></a>每日命令系列导语</h1><p>&#160; &#160; &#160; &#160;安全行业，接触Linux不可避免。今天我们开启Linux学习之旅。</p>
<p>&#160; &#160; &#160; &#160;一直在构思Linux系列文章该怎么排版，最终决定采用每日命令的形式，毕竟Linux有大量的命令需要学习。</p>
<p>&#160; &#160; &#160; &#160;每日命令系列根据命令知识点来排版。命令知识点多，一篇就只介绍一条命令；命令知识点少，就多介绍几条命令。命令以外的知识会视情况进行排版：碎片化讲解或单独发布。</p>
<p>&#160; &#160; &#160; &#160;争取让校友们看完一篇文章不会太累，也不会觉得学到的东西少。当然，文章主要面向小白，所以知识点都很基础，这也符合安全小白团的宗旨。已经掌握了基础的校友们，可以跳过。</p>
<p>&#160; &#160; &#160; &#160;学习命令，无外乎学习三个方面的内容：语法+选项+参数，所以每日命令系列主要从这三个方面进行介绍。</p>
<p>&#160; &#160; &#160; &#160;首先介绍命令的语法，然后对常用的选项进行介绍，不会介绍所有的选项(有兴趣的校友可以自己查阅资料或安装Linux实践)。最后讲讲命令的参数。当然，为了让大家更好的理解，循序渐进，我不一定会按这个顺序。</p>
<p>&#160; &#160; &#160; &#160;秉承每日系列简单粗暴的原则，废话不多话，开始每日命令系列第一章——ls命令的学习。</p>
<h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><p>&#160; &#160; &#160; &#160;ls是英文list的缩写，用于列出文件，在Unix和类Unix系统中都有实现。相当于Windows中的dir命令。</p>
<h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls  [选项] [文件]</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;以上是ls命令的语法，比较简单。其实Linux大多数命令的语法格式都是这样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令名  [选项] [参数]</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;有个疑问：我是怎么知道ls命令语法的？这里要给大家介绍一下”–help“选项。Linux命令都有这个选项，用于打印命令的帮助信息。</p>
<p>&#160; &#160; &#160; &#160;当我们不知道命令是用来干嘛的，或者命令语法/选项忘了，我们可以使用这个选项来获取命令的帮助信息。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/1-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;以上是ls命令的帮助信息。介绍了：ls命令的用法，也就是语法；ls命令的用途——列出文件的信息(默认是当前目录)；ls命令的选项。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>&#160; &#160; &#160; &#160;ls命令选项比较多，这里我们挑一些常用的选项来介绍。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在不添加任何选项和参数运行时，ls命令默认列出当前目录下隐藏文件以外的所有文件和目录。（仅列出名字）</p>
<div align="center">

<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/2-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;当前目录为根目录“/”，因此列出了该目录下隐藏文件以外的所有文件和目录的名字。</p>
<p>&#160; &#160; &#160; &#160;要注意的是，Linux是严格区分大小写的。所以如果将命令大写的话，系统是识别不出来的。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/3-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;默认情况下，只列出非隐藏的文件和目录，那有没有办法列出所有的文件和目录，包括隐藏文件和目录呢？</p>
<p>&#160; &#160; &#160; &#160;办法当然是有的，只需要在ls命令后添加“-a”选项即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;注意，命令与选项之间，选项与参数之间，都是有空格的，千万不要将三者写在一起。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/4-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;可以看到，列出的文件和目录中多了以圆点“.”开头的文件和目录。Linux中，以圆点“.”开头的文件和目录默认情况下会被隐藏，在Windows中也一样。</p>
<p>&#160; &#160; &#160; &#160;大家有没有注意到，列出的文件和目录中，有“.”和“..”。在Linux中，这分别代表当前目录和上级目录，所以大家可能经常看到以下格式的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./文件</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这条命令的意思是执行当前目录下的这个文件。假如你下载了一个脚本工具，想要运行它进行漏洞检测。你可以先进入脚本所在的目录，然后输入“./脚本名”来运行脚本。</p>
<p>&#160; &#160; &#160; &#160;如果不想打印这两个目录，可以使用“-A”选项，效果和“-a”选项一样，只是不列出“.”和“..”而已。这里再次强调，Linux严格区分大小写。</p>
<p>&#160; &#160; &#160; &#160;这么多文件和目录密密麻麻列出来，是不是感觉看着不舒服？教你一招，使用“-l”选项，以长格式列出文件和目录的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/5-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;这样看着多多少少舒服了一点。但是怎么多了一些其他的信息？这是因为“-l”选项会将文件和目录的属性打印出来，比如文件类型、权限等等。相当于Windows中右键—&gt;属性。</p>
<p>&#160; &#160; &#160; &#160;长格式中各个字段的知识点有点多，我在以后的文章再讲，这里将重心放在命令的学习上。</p>
<p>&#160; &#160; &#160; &#160;在“-l”选项列出的信息中，第5列表示文件/目录的大小，默认单位为字节，可使用“-h”选项，将单位转换为对人们友好的单位（K、M、G）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -hl</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;命令可以同时使用多个选项，多个选项写在一起即可。这条命令的意思是以长格式打印当前目录下的非隐藏文件和目录，并将大小显示成对人们友好的单位。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/6-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;在这里我想提一句：命令的选项一般都有简化形式和完整形式，无论使用哪种形式的选项，都能达到相同的效果。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/7-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;我用“–help”选项的简化模式“-h”，依然成功打印出了命令的帮助信息。但有些命令不一定有“-h”选项，或者“-h”并不是“–help”的简化。就比如ls命令，“-h”选项不是打印帮助信息。</p>
<p>&#160; &#160; &#160; &#160;所以查看帮助信息的时候，个人推荐使用完整选项”–help“。至于其他选项，当然使用简化形式，更方便使用和记忆。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&#160; &#160; &#160; &#160;命令除了可以添加选项，还可以添加参数。ls命令的参数就是文件名和目录名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls 0</span><br></pre></td></tr></table></figure>


<p>&#160; &#160; &#160; &#160;添加参数后，我们就可以列出参数指定的文件/目录的信息了。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/8-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;这里我列出了当前目录下的0文件，也可以将参数设置为指定目录。这样会列出指定目录下的文件。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/9-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;如果只想查看目录本身，不想列出目录下的文件，我们可以使用“-d”选项。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/10-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;和选项一样，也可以同时添加多个参数。注意，参数之间有空格。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/11-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;当然，命令也可以选项、参数同时使用。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/12-ls.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;以上就是ls命令的语法、常用选项、参数。</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>&#160; &#160; &#160; &#160;以下是对本文知识的总结。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法：ls  [选项] [文件]</span><br><span class="line">用途：</span><br><span class="line">    列出文件的信息（默认情况下仅列出名字）</span><br><span class="line">    如果以目录名作为参数，则会列出该目录下的文件。</span><br><span class="line">选项：</span><br><span class="line">    -a ———— 列出所有文件和目录（包括隐藏文件和目录）</span><br><span class="line">    -A ———— 列出除当前目录“.”和上级目录“..”以外的所有文件和目录（包括隐藏文件和目录）</span><br><span class="line">    -l ———— 以长格式列出文件和目录的属性</span><br><span class="line">    -h ———— 以对人类友好的单位显示文件和目录的大小</span><br><span class="line">    -d ———— 只列出目录本身，不列出目录下的文件</span><br><span class="line">参数：文件名/目录名</span><br><span class="line">其他：</span><br><span class="line">    “--help”选项可获取命令的帮助信息</span><br><span class="line">    Linux严格区分大小写</span><br><span class="line">    命令可以同时使用多个选项，多个选项写在一起即可</span><br><span class="line">    命令也可以指定多个文件和目录作为参数，ls则会列出所有指定的文件和目录中的文件名。</span><br></pre></td></tr></table></figure>

<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-ls/13-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>
]]></content>
      <categories>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 | mv、rm</title>
    <url>/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/</url>
    <content><![CDATA[<h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><p>&#160; &#160; &#160; &#160;之前我们已经讲了文件和目录的创建及复制，今天我们来讲一讲剪切和删除。</p>
<p>&#160; &#160; &#160; &#160;mv——移动、重命名文件</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/1-mv.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;rm——删除文件</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/2-rm.jpg" class>
</div>







<h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] 参数1 参数2</span><br><span class="line">rm [选项] 参数</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;mv，move的缩写，移动；rm，remove的缩写，删除。这样介绍，相信校友们更容易理解和记忆命令的用途。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在语法上，mv命令和cp命令其实很相似。选项和参数都差不多，也有三种模式。</p>
<p>&#160; &#160; &#160; &#160;不同的是，cp命令是在另一个地方复制一份文件，整个计算机就有了两份内容一样的文件；而mv命令是将文件移动到另一个地方，整个计算机还是只有一份这样的文件。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/3-mv1.jpg" class>
</div>





<p>&#160; &#160; &#160; &#160;注意，对文件执行mv命令，不会更新文件的时间属性。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/4-mv2.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;但是执行cp命令，默认情况下会更新文件的时间属性。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/5-cp.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;除了名字不一样，内容、时间属性都一样，因此mv命令也用来对文件重命名。</p>
<p>&#160; &#160; &#160; &#160;rm命令的参数可以是文件，可以是目录，也可以同时包含文件和目录，参数之间用空格隔开即可。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/6-rm1.jpg" class>
</div>


<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>&#160; &#160; &#160; &#160;mv命令的选项和cp命令的选项差不多，“-i”交互、“-n”不覆盖、“-f”强制、“-u”更新，这里不再赘述。我们讲一个“-b”备份选项，cp命令也有这个选项。</p>
<p>&#160; &#160; &#160; &#160;首先我们新建一个空文件。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/7-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;然后将1.txt移动到同目录下的2.txt，由于2.txt已经存在，所以默认会覆盖2.txt原来的内容。这个时候我们添加“-b”选项，系统会在覆盖之前，生成2.txt的备份文件。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/8-cat.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，目录下多了个2.txt~的文件，这就是原来2.txt文件的备份，所以用cat命令查看是没有内容的。</p>
<p>&#160; &#160; &#160; &#160;另外，再介绍一个“-t”选项，用于指定移动的目标目录，然后将目标目录后的所有文件移动到目标目录中。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/9-mv.jpg" class>
</div>



<p>&#160; &#160; &#160; &#160;指定目标目录为test目录，然后将test目录后跟随的1，2，3全部移动到其中。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/10-mv.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;当然也可以不使用“-t”选项，使用默认语法就可以完成以上工作。但是使用“-t”选项指定目标目录，在一定程度上能够方便大家快速理解命令的含义，这个在具体工作中，各位校友可以根据自己习惯来使用。</p>
<p>&#160; &#160; &#160; &#160;mv命令大家平时可能听的少，但rm命令我相信大家听过肯定不止一两次。什么输错命令宕机，什么从删库到跑路，基本和rm命令有关。</p>
<p>&#160; &#160; &#160; &#160;眼尖的校友可能注意到，我在讲参数的时候，用rm命令删除的是文件，而不是目录，因为rm命令默认情况下是不删除目录的。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/11-rm.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，系统明确提示无法删除，因为test是一个目录。如果想要删除目录，就必需添加“-r”选项。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/12-rm.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;但是mv命令对目录进行操作，不需要“-r”选项。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/13-rm.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;不添加“-r”选项，mv命令依然将test目录移动到了Desktop目录。</p>
<p>&#160; &#160; &#160; &#160;Linux有大量的命令，不同命令，选项各不相同。大家刚接触可能会存在记混或容易遗忘的情况，这很正常，多敲几遍就会越来越熟练的。</p>
<p>&#160; &#160; &#160; &#160;“-r”选项是rm命令使用很频繁的选项，另外一个使用很频繁的选项是“-f”选项。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/14-rm.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，在使用了“-f”选项后，系统没有任何提示直接将指定的文件和目录都删除了，这也是“rm -rf”命令经常出事的原因。</p>
<p>&#160; &#160; &#160; &#160;最后要提醒的是，执行rm命令默认是不提示的，我这里提示是因为我设置了执行rm命令会附带“-i”选项。</p>
<div align="center">
<img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/15-rm.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;这种叫做别名，执行rm命令其实是在执行“rm -i”。所以有的校友在执行rm命令时，系统没有提示就直接把文件给删除了，遇到这种情况不必惊慌，设置一下就好了。另外出于安全考虑，也建议设置提示。</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法：    </span><br><span class="line">    mv [选项] 参数1 参数2     </span><br><span class="line">    rm [选项] 参数 </span><br><span class="line">用途：    </span><br><span class="line">    mv——移动、重命名文件     </span><br><span class="line">    rm——删除文件 </span><br><span class="line">选项：mv：-i——交互 </span><br><span class="line">        -n——不覆盖 </span><br><span class="line">        -u——更新 </span><br><span class="line">        -f——强制 </span><br><span class="line">        -b——备份 -t——指定目标目录</span><br><span class="line">    rm：-r、-R——删除目录 </span><br><span class="line">        -f——强制 -d——删除空目录</span><br><span class="line">其他：alias——别名</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;实在是对不住各位校友，最近工作上事情比较多，加班没停过，短短几百字写了一个多月。今天安全形势比以往都严峻，可能没办法做到像去年一样，一周一篇或两周一篇，但我会努力抽时间码字，尽可能的缩短文章发布周期。</p>
<p>&#160; &#160; &#160; &#160;安全小白团，旨在帮助大家了解信息安全。文章内容偏向基础知识，希望能帮助更多的安全爱好者打开信息安全的大门。书山有路勤为径，学海无涯苦作舟。安全小白团，永远与你同在。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-mv%E3%80%81rm/16-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>





]]></content>
      <categories>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 | pwd、cd</title>
    <url>/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/</url>
    <content><![CDATA[<h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><p>&#160; &#160; &#160; &#160;上回说到《每日命令 | ls》，今天我们来说一说pwd命令和cd命令。</p>
<p>&#160; &#160; &#160; &#160;pwd命令——返回当前工作目录名称。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/1-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;cd命令——改变工作目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/2-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;什么是工作目录？</p>
<p>&#160; &#160; &#160; &#160;举个例子：我在北京上班，那我的工作地点就是北京；后来我到上海上班去了，那我的工作地点就变成上海了。</p>
<p>&#160; &#160; &#160; &#160;在linux中，我们当前在哪个目录下，那个目录就被称为当前的工作目录，因为我们所有的命令(工作)都是在当前目录下执行的。</p>
<h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd  [选项]</span><br><span class="line"></span><br><span class="line"> cd  [选项] [目录]</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;pwd命令只有选项，没有参数。因为它的作用是输出当前的工作目录名，所以不需要参数。</p>
<p>&#160; &#160; &#160; &#160;cd命令，既有选项，也有参数。参数为想要切换到的目录名。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&#160; &#160; &#160; &#160;pwd命令没有参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;pwd命令将我们当前所在的目录名打印出来。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/3-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，我们当前在root目录下。</p>
<p>&#160; &#160; &#160; &#160;cd命令的参数是目录名，毕竟是用来切换工作目录的。</p>
<p>&#160; &#160; &#160; &#160;首先介绍四个特殊的命令。</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd ."></a>cd .</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd .</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;上回我们说到“.”目录表示当前目录，所以这条命令的意思是切换到当前目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/4-pwd.jpg" class>
</div>





<p>&#160; &#160; &#160; &#160;在执行cd命令之前，我们在root目录下。执行“cd .”命令后，我们仍在root目录下。</p>
<p>&#160; &#160; &#160; &#160;但我们本来就在当前目录，再切换到当前目录，有点多此一举。所以这个命令一般不会用。</p>
<h3 id="cd-1"><a href="#cd-1" class="headerlink" title="cd .."></a>cd ..</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;“..”目录表示上级目录，或者说父目录。所以这条命令的意思是切换到当前目录的上一级目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/5-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，当前我们处在root目录。在执行“cd ..”命令后，我们从root目录进入了“/”根目录。</p>
<p>&#160; &#160; &#160; &#160;然后利用之前介绍的ls命令，列出当前目录下的文件和目录，发现root目录静静躺在其中。说明root目录是“/”根目录的子目录，所以cd命令才会切换到根目录。</p>
<p>&#160; &#160; &#160; &#160;那我们再切换到根目录的上级目录试试？</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/6-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;发现切换到根目录之后，再切换到根目录的上级目录，返回的结果还是根目录。</p>
<p>&#160; &#160; &#160; &#160;这是怎么回事？命令抽风了吗？</p>
<p>&#160; &#160; &#160; &#160;这是因为在Linux中，“/”根目录是系统最高目录，它没有上级目录，所以不管怎么切换，上级目录都会止步“/”目录。目录方面的知识以后会给大家讲解。</p>
<p>&#160; &#160; &#160; &#160;小技巧，要获取我们当前的工作目录名，不一定要用pwd命令，我们还可以查看shell提示符。</p>
<p>&#160; &#160; &#160; &#160;啥是shell提示符？</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/7-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;我们打开终端，红框中这种就是shell提示符。其默认组成一般是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">当前登录用户名@主机名:当前目录[$|#]</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/8-pwd.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;我们只需要看shell提示符中的目录就可以知道当前工作目录，这样是不是方便了很多？而且shell提示符是可以自定义的，我们可以根据自身习惯自定义shell提示符，方便日常工作使用。</p>
<p>&#160; &#160; &#160; &#160;另外，shell提示符最后显示“$”还是“#”，取决于登录的用户。登录的用户如果是超级用户root，则显示为“#”，如果是普通用户，则显示“$”。Linux的超级用户root就相当于Windows的Administrator。</p>
<p>&#160; &#160; &#160; &#160;这里我是用超级用户root登录的，所以shell提示符最后显示为“#”。</p>
<h3 id="cd-2"><a href="#cd-2" class="headerlink" title="cd -"></a>cd -</h3><p>&#160; &#160; &#160; &#160;接下来给大家介绍一个好玩的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;这条命令的意思是切换到我们待过的上一个目录，或者理解为我们从哪个目录切换过来的，我们就切回哪个目录。</p>
<p>&#160; &#160; &#160; &#160;用菩提祖师的话说：“悟空，从哪来，回哪去”。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/9-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;最开始我们在root目录，切换到根目录。然后在根目录执行“cd -”命令，切回到了root目录，因为在来根目录之前，我们待在root目录中。再在root目录运行同样的目录，切回到了根目录，因为来root目录之前，我们在根目录。</p>
<p>&#160; &#160; &#160; &#160;有点死循环的感觉。</p>
<h3 id="cd-3"><a href="#cd-3" class="headerlink" title="cd ~"></a>cd ~</h3><p>&#160; &#160; &#160; &#160;最后再介绍“~”目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在Linux中，“~”表示用户的家目录。</p>
<p>&#160; &#160; &#160; &#160;在多用户操作系统中，系统会为每个用户分配一个目录，作为家目录，用来保存用户的文件。</p>
<p>&#160; &#160; &#160; &#160;在Linux中，家目录分两种：普通用户的家目录和超级用户的家目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">普通用户：/home/用户名</span><br><span class="line">超级用户：/root</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;普通用户的家目录为/home/用户名。假如用户为admin，那它的家目录就是/home/admin。</p>
<p>&#160; &#160; &#160; &#160;在Windows中也是这样的，只不过路径不一样而已。另外微信、QQ也是这样，比如QQ会以QQ号为目录，为不同用户存放文件。以前没注意过的校友可以在自己电脑操作一下。</p>
<p>&#160; &#160; &#160; &#160;超级用户的家目录为/root。超级用户可以查看普通用户的家目录，而普通用户不能查看超级用户的家目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/10-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，执行“cd <del>”命令的效果和执行“cd /root”命令的效果一样。因为我是用root用户登录的，此时“</del>”目录就是root目录。</p>
<p>&#160; &#160; &#160; &#160;另外，可以用“cd ~用户名”切换到其他用户的家目录。</p>
<p>&#160; &#160; &#160; &#160;当然，也可以不指定目录，这种情况cd命令会切换到当前登录用户的家目录，和“cd ~”命令一样的效果。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/11-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;四个特殊命令介绍完了，接下来给大家介绍常规目录的切换方法。</p>
<p>&#160; &#160; &#160; &#160;常规目录的切换有两种方式：相对路径和绝对路径。</p>
<p>&#160; &#160; &#160; &#160;在物理学习中，相信大家都接触过参照物。在Linux中，相对路径和绝对路径也和参照物有关。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/12-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;以上是tomcat目录的结构：在根目录下的root目录的vulhub-master目录中。下面我们分别用相对路径和绝对路径来进入tomcat目录。</p>
<p>&#160; &#160; &#160; &#160;相对路径的参照物是当前的工作目录。如果使用相对路径的方式进行切换，目录路径则以当前工作目录为起点。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/13-pwd.jpg" class>
</div>





<p>&#160; &#160; &#160; &#160;也可以“逆流而上”切换到别的目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/14-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;当前我们在tomcat目录。</p>
<p>&#160; &#160; &#160; &#160;“../../Desktop”的意思是上级目录的上级目录下的Desktop目录。</p>
<p>&#160; &#160; &#160; &#160;tomcat目录的上级目录是vulhub-master目录，vulhub-master目录的上级目录是root目录，然后再切换到root目录下的Desktop目录。</p>
<p>&#160; &#160; &#160; &#160;以上是使用相对路径进行切换的案例，下面介绍怎么使用绝对路径切换工作目录。</p>
<p>&#160; &#160; &#160; &#160;之前提到，Linux的最高目录是“/”目录，Linux所有文件和目录都在“/”目录中，而绝对路径的参照物就是“/”目录。</p>
<p>&#160; &#160; &#160; &#160;如果想使用绝对路径的方式来切换目录，很简单，只需要遵循一点，那就是目录的路径必须从“/”目录开始。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/15-pwd.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;无论使用那种路径，只要路径正确，都能达到同样的目的。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>&#160; &#160; &#160; &#160;pwd和cd命令都有选项，但是在日常工作中，这两条命令的选项其实用的很少。</p>
<p>&#160; &#160; &#160; &#160;因为默认情况下，这两条命令已经足够满足我们的需求了。所以这里不再阐述，有兴趣的校友可以查阅相关资料。</p>
<h1 id="命令选项总结"><a href="#命令选项总结" class="headerlink" title="命令选项总结"></a>命令选项总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">    pwd  [选项]</span><br><span class="line">     cd  [选项] [目录]</span><br><span class="line">用途：</span><br><span class="line">    pwd————打印当前工作目录</span><br><span class="line">     cd————切换工作目录</span><br><span class="line">参数：</span><br><span class="line">    pwd命令没有参数，cd命令的参数是目录名</span><br><span class="line">其他：</span><br><span class="line">    cd .    切换到当前目录</span><br><span class="line">    cd ..   切换到上级目录</span><br><span class="line">    cd -    切换到上一目录</span><br><span class="line">    cd ~    切换到家目录</span><br><span class="line">    cd ~用户名    切换到其他用户的家目录    </span><br><span class="line">    root用户：shell提示符最后显示#;普通用户：shell提示符最后显示$</span><br><span class="line">    root可以查看其他用户的家目录,普通用户不能查看root的家目录</span><br><span class="line">    相对路径相对于当前工作目录，绝对路径相对于“/”目录。</span><br></pre></td></tr></table></figure>





<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-pwd%E3%80%81cd/16-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>






]]></content>
      <categories>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 | touch、mkdir</title>
    <url>/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/</url>
    <content><![CDATA[<h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><p>&#160; &#160; &#160; &#160;任何事物都有生命周期，Linux中的文件和目录也一样：创建、修改、删除。今天我们来讲一讲文件和目录的创建。</p>
<p>&#160; &#160; &#160; &#160;touch——修改文件的访问时间和修改时间（可用来创建空文件）</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/1-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;mkdir——make directory，创建目录</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/2-mkdir.jpg" class>
</div>








<h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir  [选项] 目录名</span><br><span class="line">touch  [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;mkdir和touch两条命令，都有选项和参数。只不过mkdir命令的参数是目录名，而touch命令的参数是文件名而已。</p>
<p>&#160; &#160; &#160; &#160;这里跟大家强调一下：选项和参数的可选，不同命令的要求是不一样的。</p>
<p>&#160; &#160; &#160; &#160;选项对命令来说，一般都是可选的。参数是否可选，不同命令有各自的规定。如果可选，我会添加方括号“[ ]”；如果不可选，也就是必需，则不会添加方括号“[ ]”。</p>
<p>&#160; &#160; &#160; &#160;因此，语法中选项加了“[ ]”，代表选项不是必需的，可以省略；但两条命令的参数，我都没加“[ ]”，证明这两条命令在使用时必需提供参数。请各位校友注意这些细节。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/3-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，系统明确提示命令缺少操作数，也就是参数。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir  目录名</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;mkdir命令的参数是要创建的目录的名字。严格来讲，参数是要创建的目录的路径名。</p>
<p>&#160; &#160; &#160; &#160;我们可以只提供要创建的目录的名字。这种情况下，系统会在当前的工作目录中创建目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/4-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，在当前的工作目录中创建了new_dir目录。另外目录名可以包含空格，但这个时候目录名需要用引号括起来。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/5-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;我们也可以指定目录的路径。这个时候，就会在我们指定的路径下创建目录。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/6-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;这两者可以想象成软件的默认安装和自定义安装，这样可能形象些，方便大家理解。</p>
<p>&#160; &#160; &#160; &#160;如果要创建的目录已经存在，系统则会报错，提示目录已经存在。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/7-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;touch命令，主要是用于修改文件和目录的访问时间和修改时间，但默认情况下，参数指定的文件不存在的话，touch命令会创建该文件。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/8-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;和创建目录一样，不指定路径的话，会在当前工作目录创建文件。我们也可以指定文件路径。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/9-touch.jpg" class>
</div>


<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>&#160; &#160; &#160; &#160;mkdir命令和touch命令可以同时处理多个参数。在提供多个参数时，我们只需要用空格分隔参数即可。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/10-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，在同级目录中创建了两个目录和文件。那可以在新建目录的同时，再在其中新建一个目录吗？</p>
<p>&#160; &#160; &#160; &#160;试试看。通过如下命令在创建father_dir目录的同时，在其中新建son_dir目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir father_dir/son_dir</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/11-touch.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;发现系统报错，原因我在图片中已经标明。这条命令的意思根本不是在新建father_dir目录的同时，在其中新建son_dir目录，而是在当前目录的father_dir中新建son_dir目录，这其实是在指定新建目录的相对路径。但此时当前目录并不存在father_dir目录，所以系统才会报错。</p>
<p>&#160; &#160; &#160; &#160;那难道只能新建一个目录，然后切换到新目录中再新建子目录，这样一层一层进行吗？</p>
<p>&#160; &#160; &#160; &#160;当然不是的，如果只能这样的话，几十层的目录创建不得创建半天？当然一般也不会有这么多层。</p>
<p>&#160; &#160; &#160; &#160;mkdir命令提供了一个很人性化的”-p“选项，让我们可以很轻松的实现这些工作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p  目录名/目录名/.../目录名</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/12-touch.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;加了”-p“选项后，系统没有报错，在新建father_dir目录的同时，在其中新建了son_dir目录。</p>
<p>&#160; &#160; &#160; &#160;这就是”-p“选项的功效：创建通向指定目录但尚不存在的所有目录。换句话说，就是将路径中不存在的目录全部创建。</p>
<p>&#160; &#160; &#160; &#160;father_dir/son_dir，最开始，当前目录不存在father_dir目录，就先创建father_dir目录；创建完后发现father_dir目录下没有son_dir目录，就继续创建son_dir目录，直到路径中所有目录都存在。也有人把这称为“递归创建”。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/13-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;mkdir命令常用的选项还有“-v”选项和“-m”选项。“-v”选项的作用是每创建一个目录就打印一条信息，“-m”选项的作用是设置目录的权限。这里先介绍一下“-v”选项，“-m”选项等以后介绍权限时再讲。</p>
<p>&#160; &#160; &#160; &#160;上一章节说到要创建的目录如果已经存在，系统则会报告，那么如果创建的文件已经存在，系统会报错吗？</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/14-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;可以看到，系统并没有报错，但好像也看不出有啥区别。这就涉及时间属性了。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/15-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;利用长格式查看详细信息，发现两次命令后，文件时间不一样。我们可以使用stat命令查看文件更为详细的状态信息。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/16-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;列出的信息中有三个时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Access：访问时间；读取但不修改文件内容</span><br><span class="line">Modify：修改时间；修改文件内容</span><br><span class="line">Change：改动时间；属性和位置的改动</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在文件存在的情况下，touch命令默认会修改文件的访问时间和修改时间。但它提供了“-a”选项和“-m”选项，分别只修改访问时间或修改时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch -a file.txt</span><br></pre></td></tr></table></figure>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/17-touch.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;“-a”选项，只改变访问时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch -m file.txt</span><br></pre></td></tr></table></figure>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/18-touch.jpg" class>
</div>


<p> &#160; &#160; &#160; &#160;“-m”选项，只改变修改时间。</p>
<p>&#160; &#160; &#160; &#160;除了可以指定修改哪种时间属性，还可以指定时间属性的值（默认是当前时间）。</p>
<p>&#160; &#160; &#160; &#160;指定时间属性的值有两种选项：”-t“选项和”-d“选项。效果一样，只是值的格式不一样而已。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/19-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;“-t”选项的时间格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[CC]YY]MMDDhhmm[.ss]</span><br><span class="line">其实就是世纪、年、月、日、时、分、秒的英文首字母。</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/20-touch.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;“-d”选项相对“-t”选项，时间格式会多一些。图片中是其中的一种，其他格式这里不再赘述，有兴趣的校友可自行查询资料。</p>
<p>&#160; &#160; &#160; &#160;touch命令还有个“-c”选项。在默认情况下，如果文件不存在，touch命令会新建空文件；加了“-c”选项之后，就不会创建文件。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/21-touch.jpg" class>
</div>









<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">    mkdir  [选项] 目录名</span><br><span class="line">    touch  [选项] 文件名</span><br><span class="line">用途：</span><br><span class="line">    mkdir————创建空目录</span><br><span class="line">    touch————修改文件和目录的访问时间和修改时间（默认情况下创建空文件）</span><br><span class="line">参数：</span><br><span class="line">    mkdir：目录的路径名（若只提供目录名，则在当前工作目录中创建目录）</span><br><span class="line">    touch：文件的路径名（若只提供文件名，则在当前工作目录中创建文件）选项：</span><br><span class="line">    mkdir：-p————递归创建</span><br><span class="line">    touch：-a————只更新访问时间</span><br><span class="line">           -m————只更新修改时间</span><br><span class="line">           -t、-d————指定时间属性的值</span><br><span class="line">           -c————即使文件不存在也不创建文件</span><br><span class="line">其他：</span><br><span class="line">    stat命令：查看文件或文件系统的状态信息</span><br></pre></td></tr></table></figure>





<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4-touch%E3%80%81mkdir/22-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>





]]></content>
      <categories>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每日漏洞 | CRLF注入</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;在《HTTP | HTTP报文》一文中，我们介绍了HTTP报文的结构：状态行和首部中的每行以CRLF结束，首部与主体之间由一空行分隔。或者理解为首部最后一个字段有两个CRLF，首部和主体由两个CRLF分隔。</p>
<p>&#160; &#160; &#160; &#160;CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为HTTP响应拆分漏洞（HTTP Response Splitting）。</p>
<h1 id="漏洞知识拓展"><a href="#漏洞知识拓展" class="headerlink" title="漏洞知识拓展"></a>漏洞知识拓展</h1><p>&#160; &#160; &#160; &#160;CRLF 指的是回车符(CR，ASCII 13，\r，%0d) 和换行符(LF，ASCII 10，\n，%0a)。</p>
<p>&#160; &#160; &#160; &#160;CRLF的概念源自打字机，表明行的结束，计算机出现后沿用了这个概念。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">回车符：光标移到行首，</span><br><span class="line">换行符：光标垂直移到下行。</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;键盘上的回车键(Enter)就可以执行该操作。但是不同的操作系统，行的结束符是不一样的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows：使用CRLF表示行的结束</span><br><span class="line">Linux/Unix：使用LF表示行的结束</span><br><span class="line">MacOS：早期使用CR表示，现在好像也用LF表示行的结束</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;所以同一文件在不同操作系统中打开，内容格式可能会出现差异，这是行结束符不一致导致的。</p>
<p>&#160; &#160; &#160; &#160;在HTTP规范中，行应该使用CRLF来结束。首部与主体由两个CRLF分隔，浏览器根据这两个CRLF来获取HTTP内容并显示。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;CRLF注入漏洞的本质和XSS有点相似，攻击者将恶意数据发送给易受攻击的Web应用程序，Web应用程序将恶意数据输出在HTTP响应头中。（XSS一般输出在主体中）</p>
<p>&#160; &#160; &#160; &#160;所以CRLF注入漏洞的检测也和XSS漏洞的检测差不多。通过修改HTTP参数或URL，注入恶意的CRLF，查看构造的恶意数据是否在响应头中输出。</p>
<h2 id="找到输入点，构造恶意的CRLF字符"><a href="#找到输入点，构造恶意的CRLF字符" class="headerlink" title="找到输入点，构造恶意的CRLF字符"></a>找到输入点，构造恶意的CRLF字符</h2><p>&#160; &#160; &#160; &#160;正常请求</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/1-CRLF.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;抓包，在请求行的url参数中加入特殊构造的CRLF字符，如下图标记所示。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/2-CRLF.jpg" class>
</div>

<h2 id="查看恶意数据是否在响应头中输出"><a href="#查看恶意数据是否在响应头中输出" class="headerlink" title="查看恶意数据是否在响应头中输出"></a>查看恶意数据是否在响应头中输出</h2><p>&#160; &#160; &#160; &#160;将修改后的请求包提交给服务器端，查看服务器端的响应。发现响应首部中多了个Set-Cookie字段。这就证实了该系统存在CRLF注入漏洞，因为我们输入的恶意数据，作为响应首部字段返回给了客户端。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/3-CRLF.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;很多人看到这里可能就想不明白，我请求包写入的恶意数据，怎么就被当成响应首部字段输出了？下面我们来看看服务器端源代码。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/4-CRLF.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;这是其中一段代码，用PHP写的，需要大家有一定的语言基础。看不懂也没关系，我后期会写PHP系列文章。这段代码的意思是：当条件满足时，将请求包中的url参数值拼接到Location字符串中，并设置成响应头发送给客户端。</p>
<p>&#160; &#160; &#160; &#160;此时服务器端接收到的url参数值是我们修改后的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://itsecgames.blogspot.com%0d%0aSet-Cookie:crlf=true</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;在url参数值拼接到Location字符串中，设置成响应头后，响应包此时应该是下图这样的：</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/5-CRLF.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;%0d和%0a分别是CR和LF的URL编码。前面我们讲到，HTTP规范中，行以CRLF结束。所以当检测到%0d%0a后，就认为Location首部字段这行结束了，Set-Cookie就会被认为是下一行，如下图所示。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/6-CRLF.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;而我们构造的Set-Cookie字符在HTTP中是一个设置Cookie的首部字段，这个时候就会将crlf=true设置成Cookie。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/7-CRLF.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;<br>&#160; &#160; &#160; &#160;重新请求，抓包，发现Cookie中多了crlf=true。</p>
<p>&#160; &#160; &#160; &#160;测试的用例大家可能会觉得这漏洞没什么危害性，但试想一下：利用漏洞，注入一个CRLF控制用户的Cookie，或者注入两个CRLF，控制返回给客户端的主体，该漏洞的危害不亚于XSS。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;过滤 \r 、\n 之类的行结束符，避免输入的数据污染其他 HTTP 首部字段。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-CRLF%E6%B3%A8%E5%85%A5/8-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>
]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>每日漏洞 | HTTP.sys远程代码执行</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-HTTP-sys%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;上篇文章介绍了Host头攻击，今天我们讲一讲HTTP.sys远程代码执行漏洞。</p>
<p>&#160; &#160; &#160; &#160;HTTP.sys是Microsoft Windows处理HTTP请求的内核驱动程序，为了优化IIS服务器性能，从IIS6.0引入，IIS服务进程依赖HTTP.sys。HTTP.sys远程代码执行漏洞实质是HTTP.sys的整数溢出漏洞，当攻击者向受影响的Windows系统发送特殊设计的HTTP 请求，HTTP.sys 未正确分析时就会导致此漏洞，成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。</p>
<p>&#160; &#160; &#160; &#160;主要存在Windows+IIS的环境下，任何安装了微软IIS 6.0以上的Windows Server 2008 R2/Server 2012/Server 2012 R2以及Windows 7/8/8.1操作系统都受到这个漏洞的影响。</p>
<h1 id="漏洞知识拓展"><a href="#漏洞知识拓展" class="headerlink" title="漏洞知识拓展"></a>漏洞知识拓展</h1><p>&#160; &#160; &#160; &#160;说到HTTP.sys远程代码执行漏洞，不得不先介绍一下Range首部字段。</p>
<p>&#160; &#160; &#160; &#160;在“上古时代”，网络并不是很好，下载大型文件很不容易。下载途中如果网络中断，就得重头开始下。为了解决这个问题，HTTP/1.1引入了范围请求。</p>
<div align="center">
    
</div>


<p>&#160; &#160; &#160; &#160;在请求报文的Range首部字段中指定资源的byte范围，告诉服务器，请求的是资源哪个范围的内容，让断点续传和并行下载得以实现。</p>
<p>&#160; &#160; &#160; &#160;如果服务器支持范围请求，响应包中就会存在Accept-Ranges字段(且值不为“none”，bytes为资源范围的单位)，并在Content-Length字段中告诉客户端资源的大小范围。</p>
<div align="center">
    
</div>


<p>&#160; &#160; &#160; &#160;如果没有Accept-Ranges字段，则服务器可能不支持范围请求，有的服务器会明确将值设为“none”。</p>
<p>&#160; &#160; &#160; &#160;服务器面对范围请求，有三种响应：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请求成功：</span><br><span class="line">    响应206 Partial Content</span><br><span class="line">请求范围越界：（范围超过资源的大小）</span><br><span class="line">    响应416 Requested Range Not Satisfiable</span><br><span class="line">不支持范围请求：</span><br><span class="line">    响应200 OK</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;而HTTP.sys远程代码执行漏洞正是利用Range字段注入恶意数据。该漏洞的检测，也是利用服务器面对范围请求时的响应特征来判断。</p>
<p>&#160; &#160; &#160; &#160;当然，范围请求不止这些知识点，详情可查看RFC：</p>
<p><a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7233</a></p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;HTTP.sys漏洞的检测比较简单，先判断目标环境是不是Windows+IIS，然后构造Range字段进行检测即可。</p>
<p>&#160; &#160; &#160; &#160;检测时，在请求包中添加Range字段，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Range: bytes=0-18446744073709551615</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;提交给服务器，查看服务器响应。</p>
<div align="center">
    
</div>

<p>&#160; &#160; &#160; &#160;服务器响应400，证明不存在HTTP.sys远程代码执行漏洞。如果响应416，则证明系统存在漏洞。</p>
<div align="center">
    
</div>

<p>&#160; &#160; &#160; &#160;这里简单说一下Range字段值的含义。18446744073709551615转为十六进制是 0xFFFFFFFFFFFFFFFF(16个F），是64位无符号整型所能表达的最大整数，整数溢出和这个超大整数有关。</p>
<p>&#160; &#160; &#160; &#160;另外，Apache几个老版本存在的Apache HTTP Server畸形Range选项处理远程拒绝服务漏洞，也是通过Range字段触发的，有兴趣的校友可以去了解了解。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;升级补丁：</p>
<p><a href="http://technet.microsoft.com/security/bulletin/MS15-034" target="_blank" rel="noopener">http://technet.microsoft.com/security/bulletin/MS15-034</a></p>
<p>&#160; &#160; &#160; &#160;禁用IIS内核缓存（缓解方案）：</p>
<p><a href="https://technet.microsoft.com/en-us/library/cc731903(v=ws.10).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/cc731903(v=ws.10).aspx</a></p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    
</div>

]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>每日漏洞 | Host头攻击</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-Host%E5%A4%B4%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;《HTTP | HTTP报文》最后一节，简单的介绍了一下首部字段，其中就包含了Host首部字段。</p>
<p>&#160; &#160; &#160; &#160;为了方便获取网站域名，开发人员一般依赖于请求包中的Host首部字段。例如，在php里用_SERVER[“HTTP_HOST”]。但是这个Host字段值是不可信赖的(可通过HTTP代理工具篡改)，如果应用程序没有对Host字段值进行处理，就有可能造成恶意代码的传入。</p>
<h1 id="漏洞知识拓展"><a href="#漏洞知识拓展" class="headerlink" title="漏洞知识拓展"></a>漏洞知识拓展</h1><p>&#160; &#160; &#160; &#160;Host首部字段是HTTP/1.1新增的，旨在告诉服务器，客户端请求的主机名和端口号，主要用来实现虚拟主机技术。</p>
<p>&#160; &#160; &#160; &#160;运用虚拟主机技术，单个主机可以运行多个站点。以下图为例，hacker和usagidesign两个站点都运行在同一服务器A上，不管我们请求哪个域名，最终都会被解析成服务器A的IP地址，这个时候服务器就不知道该将请求交给哪个站点处理，因此需要Host字段指定请求的主机名。</p>
<p>&#160; &#160; &#160; &#160;我们访问hacker域名，经DNS解析，变成了服务器A的IP，请求传达到服务器A，A接收到请求后，发现请求报文中的Host字段值为hacker，进而将请求交给hacker站点处理。（这里又涉及到计算机网络知识了，是不是觉得要学的真多？没关系，我后面都会一一介绍的）</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-Host%E5%A4%B4%E6%94%BB%E5%87%BB/1-host.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;这个时候，问题就出现了。为了方便获取网站域名，开发人员一般依赖于请求包中的Host首部字段。例如，在php里用_SERVER[“HTTP_HOST”]。但是这个Host字段值是不可信赖的(可通过HTTP代理工具篡改)，如果应用程序没有对Host字段值进行处理，就有可能造成恶意代码的传入。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;Host头攻击漏洞的检测比较简单，只需要抓包，修改Host字段值，提交，查看响应中是否包含修改后的Host字段值即可。</p>
<p>&#160; &#160; &#160; &#160;下面我分三个场景，介绍一下Host头攻击漏洞存在的表现。</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>&#160; &#160; &#160; &#160;场景一：正常请求，响应302，Location首部字段指明跳转的地址，其中Location字段值为Host字段指定的地址。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-Host%E5%A4%B4%E6%94%BB%E5%87%BB/2-host.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;将请求包的Host字段值修改为<a href="http://www.baidu.com提交，响应包中的Location地址也被更改为www.baidu.com。" target="_blank" rel="noopener">www.baidu.com提交，响应包中的Location地址也被更改为www.baidu.com。</a></p>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>&#160; &#160; &#160; &#160;场景二：正常请求，正常响应，将Host字段值拼接到标签属性值中。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-Host%E5%A4%B4%E6%94%BB%E5%87%BB/3-host.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;将请求包的Host字段值修改为<a href="http://www.baidu.com提交，发现服务器将www.baidu.com拼接到了script标签的src属性值中。" target="_blank" rel="noopener">www.baidu.com提交，发现服务器将www.baidu.com拼接到了script标签的src属性值中。</a></p>
<h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><p>&#160; &#160; &#160; &#160;场景三：这其实也属于拼接，只不过在场景二的基础上写入了恶意代码。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-Host%E5%A4%B4%E6%94%BB%E5%87%BB/4-host.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;利用Host字段写入script标签，弹出警告框。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;对Host字段进行检测。</p>
<p>&#160; &#160; &#160; &#160;Nginx，修改ngnix.conf文件，在server中指定一个server_name名单，并添加检测。</p>
<p>&#160; &#160; &#160; &#160;Apache，修改httpd.conf文件，指定ServerName，并开启UseCanonicalName选项。</p>
<p>&#160; &#160; &#160; &#160;Tomcat，修改server.xml文件，配置Host的name属性。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-Host%E5%A4%B4%E6%94%BB%E5%87%BB/5-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>

]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>每日漏洞 | 不安全的HTTP方法</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;《HTTP | HTTP报文》中介绍了HTTP的请求方法。在这些方法中，HTTP定义了一组被称为安全方法的方法：GET、HEAD、OPTIONS、TRACE，这些方法不会产生什么动作，不会在服务器上产生结果，只是简单获取信息。相对的，能产生动作的方法就会被认为是不安全的HTTP方法。</p>
<p>&#160; &#160; &#160; &#160;注意，安全方法不一定什么动作都不执行，比如在登陆时用GET方法传输数据，这个时候GET方法也会产生动作。就比如钱是用来花的，你硬要用来擦屁屁，这也没办法。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95/1-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84http%E6%96%B9%E6%B3%95.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;在HTTP认为的那些不安全的HTTP方法中，安全界认为PUT、DELETE、TRACE是不安全的，另外WebDAV中的几个方法，RFC 5789中的PATCH方法也被认为是不安全的。（TRACE容易引发XST攻击，PATCH修改资源的部分内容，PUT/DELETE没有认证机制等原因，不仅仅因为它们会产生结果）</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95/2-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84http%E6%96%B9%E6%B3%95.jpg" class>
</div>







<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;不安全的HTTP方法漏洞检测，分为两步：查询资源支持的方法、验证方法是否真的支持。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>&#160; &#160; &#160; &#160;在之前的文章里提到过，OPTIONS请求方法可以查询URL指定的资源支持哪些方法。</p>
<p>&#160; &#160; &#160; &#160;首先正常请求，抓包，然后将请求包中的请求方法修改为OPTIONS，提交，如果成功，响应包中就会出现一个Allow首部字段，里面列出了URL指定资源所支持的方法列表。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95/3-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84http%E6%96%B9%E6%B3%95.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;执行到这一步，就出现这么一种现象，有的校友在执行OPTIONS请求后，发现响应包的Allow字段中包含了PUT、DELETE等不安全方法，就直接认定系统存在漏洞。在我看来，这是不严谨的。有时候Allow字段提示支持，但实际上并不支持，因此需要进一步验证该资源是否真的支持不安全的HTTP方法。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>&#160; &#160; &#160; &#160;查询阶段显示，支持TRACE方法。那我们将OPTIONS方法修改为TRACE方法试试，如果响应包主体中包含接收到的请求，则证明支持TRACE方法，系统存在漏洞。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95/4-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84http%E6%96%B9%E6%B3%95.jpg" class>

<pre><code>{% asset_img 5-不安全的http方法.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;发现服务器报错，证明并不支持TRACE方法。(不支持一般会报405)</p>
<p>&#160; &#160; &#160; &#160;不安全HTTP方法漏洞的检测大概就是这个流程，其余不安全方法在《HTTP | HTTP报文》中介绍过，检测的时候只是利用方法的特性而已，这里就不再赘述。</p>
<p>&#160; &#160; &#160; &#160;不过要注意的是，在验证PUT和DELETE的时候，不要在原有资源上进行操作，一定要指定一个不存在的资源，比如先PUT一个文件上去，然后DELETE刚才创建的文件，只要证明支持不安全的HTTP方法即可，切记不可修改和删除服务器原有文件。</p>
<p>&#160; &#160; &#160; &#160;另外，PUT还可以和WebDAV扩展中的COPY/MOVE配合，PUT上传文件，COPY/MOVE修改文件位置和类型。</p>
<div align="center">
    {% asset_img 6-不安全的http方法.jpg %}

<pre><code>{% asset_img 7-不安全的http方法.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;具体怎么用，请自行百度，点到即止。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;修改配置文件，禁用不安全的HTTP方法。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95/8-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>每日漏洞 | rsync未授权访问</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-rsync%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;rsync是Linux/Unix下的一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件和目录，默认运行在873端口。由于配置不当，导致任何人可未授权访问rsync，上传本地文件，下载服务器文件。</p>
<p>&#160; &#160; &#160; &#160;rsync未授权访问带来的危害主要有两个：一是造成了严重的信息泄露；二是上传脚本后门文件，远程命令执行。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;rsync未授权访问漏洞只需使用rsync命令即可进行检测。首先使用nmap或其他工具对目标服务器进行端口扫描，当检测到目标服务器开放873端口后，使用rsync命令，查看是否能获取到模块名列表（需要同步的目录），然后查看模块内的文件，rsync未授权访问漏洞的检测就是如此简单。</p>
<h2 id="查看模块名列表"><a href="#查看模块名列表" class="headerlink" title="查看模块名列表"></a>查看模块名列表</h2><p>&#160; &#160; &#160; &#160;使用如下两条命令之一，列出目标服务器的同步目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync ip::</span><br><span class="line">rsync rsync://ip:873</span><br></pre></td></tr></table></figure>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-rsync%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/1-rsync.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;两条命令都列出了目标服务器的同步目录，在验证的时候任意使用其中一条命令即可。</p>
<h2 id="查看模块文件"><a href="#查看模块文件" class="headerlink" title="查看模块文件"></a>查看模块文件</h2><p>&#160; &#160; &#160; &#160;获取到目录之后，只需在路径后添加目录名即可查看目录中的文件。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-rsync%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/2-rsync.jpg" class>

<pre><code>{% asset_img 3-rsync.jpg %}</code></pre></div>



<p>&#160; &#160; &#160; &#160;到这里，rsync未授权访问漏洞就验证成功了，之后的步骤不再赘述。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;更改rysnc默认配置文件/etc/rsyncd.conf，添加或修改参数：</p>
<p>&#160; &#160; &#160; &#160;访问控制；设置host allow，限制允许访问主机的IP。</p>
<p>&#160; &#160; &#160; &#160;权限控制；设置read only，将模块设置成只读。</p>
<p>&#160; &#160; &#160; &#160;访问认证；设置auth、secrets，认证成功才能调用服务。</p>
<p>&#160; &#160; &#160; &#160;模块隐藏；设置list，将模块隐藏。</p>
<p>&#160; &#160; &#160; &#160;详情可参考官方doc：<a href="https://rsync.samba.org/ftp/rsync/rsyncd.conf.html" target="_blank" rel="noopener">https://rsync.samba.org/ftp/rsync/rsyncd.conf.html</a></p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-rsync%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/4-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
      <tags>
        <tag>未授权访问</tag>
      </tags>
  </entry>
  <entry>
    <title>每日漏洞 | 会话固定</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;当用户成功验证而应用程序不更新cookie时，这个时候就存在会话固定漏洞，攻击者可利用此漏洞发起会话劫持。</p>
<p>&#160; &#160; &#160; &#160;HTTP的无状态性，导致Web应用程序必须使用会话机制来识别用户。如果用户未登录时的会话ID和登录后的会话ID保持一致，那么攻击者可以迫使受害者使用一个已知(有效)的会话ID，当受害者通过身份验证，攻击者就可以利用这个会话ID进入验证后的会话（登录状态）。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;在理解漏洞原理后，怎么检测会话固定漏洞就很明显了，只需查看登录前和登录后的会话ID是否一致即可。查看的方式有多种，如浏览器F12，抓包工具等。</p>
<h2 id="登录前查看客户端的会话ID"><a href="#登录前查看客户端的会话ID" class="headerlink" title="登录前查看客户端的会话ID"></a>登录前查看客户端的会话ID</h2><div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A/1-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A.jpg" class>
</div>

<h2 id="输入账号密码通过验证后查看客户端的会话ID"><a href="#输入账号密码通过验证后查看客户端的会话ID" class="headerlink" title="输入账号密码通过验证后查看客户端的会话ID"></a>输入账号密码通过验证后查看客户端的会话ID</h2><div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A/2-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;发现登录前后的会话ID是一样的，这样说明系统存在会话固定漏洞，利用漏洞就是水到渠成的事了。先在Web应用程序上创建一个会话并记录对应的有效会话ID，然后通过各种手段促使受害者使用这个会话ID通过服务器验证，这样攻击者就可以通过这个会话ID进入受害者的账户。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;应用在用户验证成功后，先让原来的会话ID失效，然后提供一个新的会话ID给用户。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A/3-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>每日漏洞 | 用户枚举</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;由于错误配置或设计缺陷，当向系统提交有效账户和无效账户时，服务器会有不同的响应。利用响应的不同，攻击者可以获取到系统已经存在的账户，可用于暴力破解，进一步获取账户的登录密码。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;用户枚举漏洞的检测比较简单，只需用不同的账户去登录，查看服务器响应是否有差异即可（查看页面、查看响应包等）。</p>
<h2 id="有效账户"><a href="#有效账户" class="headerlink" title="有效账户"></a>有效账户</h2><p>&#160; &#160; &#160; &#160;输入系统存在的账户和任意密码，系统响应密码错误。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE/1-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE.jpg" class>
</div>

<h2 id="无效账户"><a href="#无效账户" class="headerlink" title="无效账户"></a>无效账户</h2><p>&#160; &#160; &#160; &#160;输入系统不存在的账户和任意密码，系统响应用户名不存在。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE/2-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;有效账户和无效账户的系统响应存在差异，这就表示系统存在用户枚举漏洞。简单的测试，我们就获取到了系统已经存在的admin账户，而且按照国际流程，admin很可能是系统管理账户。我们可以用字典去爆破admin的登陆密码，也可以继续枚举系统存在的其他账户，进一步确定可攻击对象。<br>附带一下以前遇到过的情况。输入admin账户时，不仅会提示用户名或密码不正确，还会提示还有几次登录机会。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE/3-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;但输入其他账户时，只会提示用户名或密码不正确。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE/4-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;这种情况，别的不敢肯定，但admin账户一定存在。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;统一身份验证失败时的响应，如：用户名或密码错误。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE/5-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>每日漏洞 | 跨站脚本攻击</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;当应用程序没有验证输入数据并产生输出时，这个时候就会产生XSS漏洞，攻击者可利用此漏洞进行Cookie窃取、会话劫持、钓鱼等攻击。</p>
<p>&#160; &#160; &#160; &#160;“一切输入都是不安全的”，Web应用的漏洞几乎都是由一个原因造成：不能在使用前正确验证输入的数据。XSS便是其中之一，攻击者可以在网页中写入恶意脚本，用户访问或点击的时候就会被执行。通常是由JavaScript编写，偶尔也会使用ActionScript、VBScript。XSS能利用到何种程度，取决于如何编写脚本，当然，和上下文环境也有关系。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;要判断系统是否存在XSS，只需要测试能否操纵应用程序参数输入，使其产生恶意输出即可，因此XSS漏洞的检测，有三大要点：输入点，输出点，以及恶意输出。</p>
<p>&#160; &#160; &#160; &#160;输入点，数据输入的参数位置。客户端与服务器端的交互，是通过请求和响应实现的，请求的时候往往会附带一些参数，这些参数就是数据的输入点，我们需要修改这些参数的值来影响服务器端的响应，并根据响应找出输出点。</p>
<p>&#160; &#160; &#160; &#160;输出点，输入数据的输出位置。有些数据输入后，经过服务器处理，往往会返回给客户端，可能出现在html标签中，也可能出现在script脚本中，我们需要根据位置的不同而使用不同的XSS构造方式。</p>
<p>&#160; &#160; &#160; &#160;恶意输出，在XSS中通常是指由JavaScript编写的代码。这些代码能实现一定功能和页面效果：弹框、发送Cookie、键盘记录等。</p>
<h2 id="寻找输入点"><a href="#寻找输入点" class="headerlink" title="寻找输入点"></a>寻找输入点</h2><div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/1-xss.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;页面有两个输入框，要求输入名字和姓氏，然后点击GO，姓名就会显示在下方。我们现在来检测这个功能是否存在XSS。</p>
<p>&#160; &#160; &#160; &#160;开启抓包工具，设置好代理，输入名字和姓氏。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/2-xss.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;点击GO，抓到如下请求包。请求行中有三个参数，其中两个参数正好对应两个输入框，这三个参数都是潜在的XSS输入点，特别是输入框对应的firstname参数和lastname参数。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/3-xss.jpg" class>
</div>

<h2 id="寻找输出点"><a href="#寻找输出点" class="headerlink" title="寻找输出点"></a>寻找输出点</h2><p>&#160; &#160; &#160; &#160;输出点我们可以通过在响应中查找输入点的值来找到。以firstname为例，我们在响应中查找bwapp这个值的位置。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/4-xss.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;发现响应中有8个匹配的值，难道有8个输出点？很多时候，为了更快速、准确的找出输出点，我们通常会将输入点的值修改为独一无二的值，如1234567，abcde等，以保证不会和系统其他参数值雷同。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/5-xss.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;这样就准确找到了firstname这个输入点的输出点。</p>
<h2 id="恶意输出"><a href="#恶意输出" class="headerlink" title="恶意输出"></a>恶意输出</h2><p>&#160; &#160; &#160; &#160;最终XSS的检测需要结合输入点和输出点。在输入点的值中加入恶意代码，查看输出点是否会产生恶意输出。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/6-xss.jpg" class>
</div>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/7-xss.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;发现服务端没有对用户输入做任何处理就直接输出到页面上，弹出一个警告框。这就证明firstname参数存在XSS。依此流程检测，发现lastname同样存在XSS，但form参数不存在XSS。</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;输入过滤；对用户的输入进行检测，过滤掉输入中的非法字符。</p>
<p>&#160; &#160; &#160; &#160;输出编码；在将输入输出到页面之前，将输入中未过滤的特殊字符进行转义，使其以文本形式展示，而不是被解析成页面结构或脚本。</p>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>&#160; &#160; &#160; &#160;在这里要申明一下，每日漏洞系列旨在告诉大家发现漏洞的最基本操作，每日学会一个漏洞的检测方法。就比如做菜，每日漏洞系列会教你第一步点火，第二步放油，第三步炒菜，第四步出锅，但不会教你用多大的火，放多少油，炒多久，这些细节我会在其他文章里深入介绍，所以如果只看这篇文章，我只能保证你会做菜，这菜能不能吃，只能交给命运了。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/8-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>每日漏洞 | 跨站请求伪造</title>
    <url>/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>&#160; &#160; &#160; &#160;HTTP的无状态性，导致Web应用程序必须使用会话机制来识别用户。一旦与Web站点建立连接(访问、登录)，用户通常会分配到一个Cookie，随后的请求，都会带上这个Cookie，这样Web站点就很容易分辨请求来自哪个用户，该修改哪个用户的数据。如果从第三方发起对当前站点的请求，该请求也会带上当前站点的Cookie。正是这是这个缺陷，导致了CSRF的产生，利用这个漏洞可以劫持用户执行非意愿的操作。</p>
<h1 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h1><p>&#160; &#160; &#160; &#160;CSRF的利用场景常常是在用户已登录的情况下，伪造用户意愿从站外发起请求。更深入剖析：请求能从站外发起(跨站)、请求的参数和值可以伪造(伪造请求)，因此，CSRF的检测也是从这两点入手。</p>
<p>&#160; &#160; &#160; &#160;以转账为例，输入账户和金额，点击Transfer即可完成转账。我们检测该功能是否存在CSRF。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/1-csrf.jpg" class>
</div>



<h2 id="是否可跨站"><a href="#是否可跨站" class="headerlink" title="是否可跨站"></a>是否可跨站</h2><p>&#160; &#160; &#160; &#160;要检测是否可跨站，只需要操作请求头中的referer字段即可。referer字段记录了请求的来源，如果请求头中没有referer字段，或者删掉请求头中的referer字段，均响应成功，那么服务器就没有校验请求来源，存在“跨站”。</p>
<p>&#160; &#160; &#160; &#160;首先正常提交请求包，发现转账成功。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/2-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;我们可以看到请求头中有个Referer字段，其中的值表示我们是从哪个页面请求过来的。我们试着将Referer字段删除并再次提交，查看账户余额有没有变化。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/3-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;发现账户余额从990变成980，说明服务器并没有验证请求来源，可以“跨站”。</p>
<h2 id="是否可伪造请求"><a href="#是否可伪造请求" class="headerlink" title="是否可伪造请求"></a>是否可伪造请求</h2><p>&#160; &#160; &#160; &#160;伪造请求的前提是，我们知道如何去伪造请求中的参数和值，也就是说我们知道请求中包含哪些参数，知道参数的准确值或者范围。因此，检测是否可伪造请求，只需要查看请求中是否有我们无法伪造的参数和值即可。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/4-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;可以看到，请求中有4个参数，account表示账号，amount表示转账金额，这两个很好伪造，action表示执行的动作，不需要伪造，直接使用即可。token是什么东西？(Token令牌了解一下)</p>
<p>&#160; &#160; &#160; &#160;token参数的值这么长，一看就知道不好伪造。那删掉token试试，万一和referer字段一样，服务器没有对token进行校验呢。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/5-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;反复重放了几次请求，发现账户余额保持不变，很显然，token参数必须有。那我们随便改一下token的值，看请求中是不是只要有token参数就行了，但服务器并不会校验token的值。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/6-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;反复重放几次，发现账户余额依然保持不变，说明服务器对Token做了校验，请求中不能缺失token或token错误。</p>
<p>&#160; &#160; &#160; &#160;正打算放弃的时候，无聊的重放着原始请求包，突然发现账户余额变成了900。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/7-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;WTF，同一个token值好像可以反复使用，均能通过校验，难道这token是永久的？后来发现只要不退出重新登录，token会一直有效，了解了，这叫“韩式半永久”。</p>
<h2 id="验证CSRF"><a href="#验证CSRF" class="headerlink" title="验证CSRF"></a>验证CSRF</h2><p>&#160; &#160; &#160; &#160;既能“跨站”，又能伪造请求，那CSRF的验证就很简单了。重新抓包，利用抓包工具生成CSRF的POC。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/8-csrf.jpg" class>
</div>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/9-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;复制其中的HTML代码，在本地新建一个HTML页面，将复制的代码保存其中，然后在同一个浏览器中打开(不懂的请gun去学习Cookie方面的知识)。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/10-csrf.jpg" class>
</div>

<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/11-csrf.jpg" class>
</div>

<p>&#160; &#160; &#160; &#160;点击CSRF页面中的按钮，发现会跳转到转账页面，且账户余额只有400，少了500。 </p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/12-csrf.jpg" class>
</div>



<p>&#160; &#160; &#160; &#160;CSRF的检测到此圆满结束。至于CSRF的利用，简单说两句，可以构造一个链接(GET)、隐藏的表单(POST)、图片等，然后想方设法让用户点击或访问就可以了。  </p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>&#160; &#160; &#160; &#160;请求来源验证；HTTP请求头中有个referer字段，该字段记录了当前HTTP请求的来源。可以通过检查请求是否来自站外，来防御站外发起的CSRF，但不能防御从站内发起的CSRF，且存在被绕过的风险。</p>
<p>&#160; &#160; &#160; &#160;Token验证；在请求中添加攻击者无法预测的Token令牌，当请求中缺失Token或Token值不对时，则拒绝请求。请使用一次性的Token，而且记得及时更新，不然还是可以绕过。(这种情况工作中已经遇到过无数次了)</p>
<p>&#160; &#160; &#160; &#160;使用图形验证码，但可能会影响用户体验。</p>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>&#160; &#160; &#160; &#160;我这里举了一个既包含referer又包含token的例子，为了让大家更好的理解CSRF的检测，排版可能会与实际情况有些出入。实际工作中，我个人习惯先多次重放，看token是否可重复使用，如果可重复使用，自然不用修改token值或删除，只需要检测是否可“跨站”即可；如果不能重复使用，说明会校验token值，那么就不必修改token值，只需直接删除token试试，最后再测试是否可“跨站”。而且在实际利用中，token值的获取没有这么简单。只是在检测过程中，我们发现token机制存在缺陷，那我们应该防患于未然，将风险降低到零。这里简要解释一下文章内容与实际工作中相出入的几点。</p>
<p>文章风格，尽量简单明了，再以幽默风趣的方式给大家介绍漏洞的检测。个人觉得我的校友们应该能看懂，如果实在是忙于做菜和开挖掘机，没时间看懂，可以在公众号里留言，有时间我就会回复。新开的公众号，文章底部暂不支持留言，这个有点头疼。每日漏洞系列需要校友们有一定基础，定位也是定在如何检测，所以理论的东西不会介绍太多，校友们平时可以适当补充理论知识，这样更容易消化每日漏洞的内容。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的博客。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E6%AF%8F%E6%97%A5%E6%BC%8F%E6%B4%9E-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/13-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>]]></content>
      <categories>
        <category>每日漏洞</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>移动安全  | 逆向基础</title>
    <url>/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="编译简介"><a href="#编译简介" class="headerlink" title="编译简介"></a>编译简介</h1><p>&#160; &#160; &#160; &#160;在学习逆向之前，我觉得很有必要了解一下编译原理。编译是将源代码转换成目标代码的过程及动作，通常是将高级语言转变成汇编语言或机器语言。</p>
<p>&#160; &#160; &#160; &#160;在这里，首先简单介绍一下高级语言、汇编语言以及机器语言，然后再介绍APK的编译过程，为后续逆向打下基础。</p>
<p>&#160; &#160; &#160; &#160;当然，编译涉及到的知识远远不止这些，这里我只是结合APK的编译过程，选择性地介绍一些需要的知识而已。避免介绍过多的编译知识，反而导致大家无法理解的情况发生。</p>
<p>&#160; &#160; &#160; &#160;如果有兴趣，校友们可以去查阅相关书籍，了解更多关于编译的知识。</p>
<h1 id="编译详解"><a href="#编译详解" class="headerlink" title="编译详解"></a>编译详解</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>&#160; &#160; &#160; &#160;编译通常涉及到三种语言：高级语言、汇编语言、机器语言。</p>
<p>&#160; &#160; &#160; &#160;首先大家要明确的是，计算机只能理解二进制，它并不理解用C、Java、Python等高级语言写的源代码。在我们眼里，这是相加，这是调用函数；但在计算机眼里，这就是屎。</p>
<p>&#160; &#160; &#160; &#160;就和之前《网络层 | 网际协议IP（1）》介绍的”点分十进制“一样，高级语言只是对人类友好，方便人类阅读而已，如果也想让计算机理解，就必须将高级语言解释成计算机能理解的机器语言，这就是编译的作用。</p>
<p>&#160; &#160; &#160; &#160;机器语言：二进制指令集，计算机能直接识别和执行，也被称为机器码。比如0101代表加，1010代表减等等。它与硬件结构相关，不同种类的计算机，其机器语言是不相通的。所以按某种计算机机器指令编写的程序不能在另一种计算机上执行。</p>
<p>&#160; &#160; &#160; &#160;由于机器语言是由一系列0和1的构成的指令代码，对人类来说，可读性差且容易出错，于是便产生了汇编语言。</p>
<p>&#160; &#160; &#160; &#160;汇编语言：机器语言的符号化，所以又称为符号语言。用助记符来表示机器代码，比如机器语言0101写成汇编语言就是add，这样就比机器语言更加便于记忆，也更形象。</p>
<p>&#160; &#160; &#160; &#160;汇编语言是面向机器的，是机器语言的符号化，因此和机器语言一样，不同的计算机有着不同的汇编语言，它的通用性和可移植性也很差。汇编代码需通过汇编器转译成机器代码才能执行。</p>
<p>&#160; &#160; &#160; &#160;由于汇编语言依赖于硬件，且助记符量大难记，于是人们又发明了更便于使用的所谓高级语言。</p>
<p>&#160; &#160; &#160; &#160;高级语言：像Java、C、C++等都是高级语言，高度封装。相对汇编语言来说，更接近自然语言和数学公式，有较高的可读性，且和计算机硬件结构关系不大，可移植性高。</p>
<p>&#160; &#160; &#160; &#160;一般我们都是使用高级语言编写代码。高级语言写的源代码会被编译器编译成目标代码，目标代码通常是汇编代码或者机器代码。如果编译产出的是汇编代码，则用汇编器进一步将汇编代码汇编成机器代码。</p>
<p>&#160; &#160; &#160; &#160;绝大部分情况，编译的“故事发展”路线大致可以简化成如下两条：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">源代码——》机器代码</span><br><span class="line">源代码——》汇编代码——》机器代码</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;但是APK走的是另外一种路线。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">源代码——》字节码——》机器代码</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;字节码，是编译产生的中间代码，需要通过特定的虚拟机将字节码转译成物理主机的机器代码。对虚拟机来说，字节码就是虚拟机的机器码，但不是物理主机的机器码。</p>
<p>&#160; &#160; &#160; &#160;这样做有什么好处？不同机器，其机器代码都是不一样的。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标语言。而将源代码编译成字节码后，只需要安装特定的软件和软件环境，就可以将其转译成机器代码。只需要编译一次，而不需要考虑平台的问题，平台的差异全部交给软件去处理。Java就是采用这种方式，因此可以”一次编译，到处运行“。</p>
<p>&#160; &#160; &#160; &#160;举个例子，生产红、蓝、绿三种颜色的纸张。如果采用寻常的编译方式，则需要三个车床分别生产；而采用字节码的编译方式，我只需要一个生产白色纸张的车床，然后交给第三方去染色就行了。这个例子应该很形象吧？</p>
<h2 id="APK编译"><a href="#APK编译" class="headerlink" title="APK编译"></a>APK编译</h2><p>&#160; &#160; &#160; &#160;目前android应用开发主流语言是Java，还有近几年被官宣的Kotlin，当然还支持其他语言，这里我们只讲Java。</p>
<p>&#160; &#160; &#160; &#160;首先给出APK编译打包的流程图。</p>
<div align="center">
    <img src="/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/1-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;这里我将APK的编译过程简化成如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">源文件——》.class文件——》.dex文件——》打包成APK——》签名</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;首先是Java源文件编译成.class文件，这里大家应该是没有疑问的。因为这是Java的编译方式，Android应用是用Java写的，理所当然要经过这一步。</p>
<p>&#160; &#160; &#160; &#160;虽然Android应用是用Java开发，但它并没有采用JVM，而是采用了Dalvik虚拟机。</p>
<p>&#160; &#160; &#160; &#160;什么？JVM和Dalvik虚拟机是什么？</p>
<p>&#160; &#160; &#160; &#160;上文提到字节码需要特定的虚拟机去转译成机器码，JVM就是Java Virtual Machine，即Java虚拟机，用来将Java编译后的.class字节码文件转译成机器码。</p>
<p>&#160; &#160; &#160; &#160;而Dalvik虚拟机是用于Android平台的虚拟机，但它支持的是.dex字节码文件（这种格式更适合Android平台运行），因此需要将.class文件转换成.dex文件。dex即Dalvik Executable，Dalvik可执行文件。</p>
<p>&#160; &#160; &#160; &#160;将源代码转译成.dex格式后，然后同其他文件（图片、配置文件等）一起打包成APK。到这一步，APK文件已经生成了。</p>
<p>&#160; &#160; &#160; &#160;最后，Android应用程序需要签名才能在Android设备上安装。所以还需要对生成的APK文件签名。</p>
<p>&#160; &#160; &#160; &#160;当然，APK编译打包不止这五个步骤，也不止这么点细节，但我觉得了解这五个步骤差不多足够了，免得讲多了大家一头雾水。后续有需要的话，我也会适当补充的。</p>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/2-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>





]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
  </entry>
  <entry>
    <title>网络层 | 网际协议IP(1)</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-1/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&#160; &#160; &#160; &#160;Internet Protocol，网际协议，是TCP/IP体系中网络层的主要协议。</p>
<p>&#160; &#160; &#160; &#160;网络层的任务是为互联网上的不同主机提供通信服务，主要完成两件事：对传输层的数据进行封装、将封装后的数据从源地址转发到目的地址。因此IP协议的主要任务也是寻址路由、封包解包。</p>
<p>&#160; &#160; &#160; &#160;在《网际协议IP》系列文章中，主要介绍IP地址的格式及分类、一些特殊的IP地址、划分子网、构成超网、数据报格式、路由、与网际协议IP相关的一些协议等方面的知识，旨在希望校友们能对网际协议IP有比较系统的了解。当然也不排除误写漏写的情况，如果有校友发现，请在公众号留言，我会及时修改。</p>
<p>&#160; &#160; &#160; &#160;下面开始《网际协议IP》系列第一部分的学习。</p>
<h1 id="IP地址详解"><a href="#IP地址详解" class="headerlink" title="IP地址详解"></a>IP地址详解</h1><p>&#160; &#160; &#160; &#160;Internet Protocol Address，互联网协议地址，又称IP地址，用于识别互联网中的设备。</p>
<p>&#160; &#160; &#160; &#160;互联网中的设备要想正常通信，就必须配置正确的IP地址。通俗点讲：要想上网，就必须有正确的IP地址。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>&#160; &#160; &#160; &#160;目前互联网使用IP协议有两个版本：IPv4和IPv6。在这里只介绍IPv4地址，IPv6地址后面再介绍。</p>
<p>&#160; &#160; &#160; &#160;IPv4地址由32位二进制数组成，为了提高可读性，对人类更加友好，通常采用 “点分十进制法” 表示IP地址，具体的做法如图所示：</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-1/1-%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6.jpg" class>
</div>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">（1）每八位二进制数为一组，将32位的IP地址分为4组</span><br><span class="line">（2）将每组二进制数转换为十进制数</span><br><span class="line">（3）用“.”将四组十进制数隔开，转换成对人类友好的IP地址表现形式</span><br></pre></td></tr></table></figure>

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>&#160; &#160; &#160; &#160;为便于寻址和层次化构造网络，IPv4地址被设计成由网络号+主机号组成。</p>
<p>&#160; &#160; &#160; &#160;网络号标明设备连接的网络，网络号在互联网中是唯一的。主机号标明设备本身，主机号在网络范围内是唯一的。因此，IP在整个互联网中是唯一的。</p>
<p>&#160; &#160; &#160; &#160;打个比方，寄快递。我在某云爸爸那里买个东西，寄到北京朝阳区xxxx。快递不会直接寄到具体地址这里，正常的流程应该是这样：快递公司一看地址是北京朝阳区，那它直接把快递寄到朝阳区；寄到朝阳区后，再由快递小哥寄到xxxx。这里北京朝阳区就是网络号，xxxx就是主机号，邮编就有这种作用。</p>
<p>&#160; &#160; &#160; &#160;早期的IPv4地址，前八位为网络号，后二十四位为主机号。随着互联网的发展，RFC 791对IPv4地址的定义做了修改，将IPv4地址分为了ABC三类单播地址。再后来，D类和E类也被定义。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-1/2-%E5%88%86%E7%B1%BB%E7%BD%91%E7%BB%9C.jpg" class>
</div>


<p>&#160; &#160; &#160; &#160;ABCDE类，根据IP地址网络号中的前几位来标识（被称为类别位），定义了网络的大小和类型。其中ABC三类为单播地址，是最常用的，D类为多播地址，E类保留为今后使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A类：前8位为网络号，后24位为主机号，类别位为0</span><br><span class="line">B类：前16位为网络号，后16位为主机号，类别位为10</span><br><span class="line">C类：前24位为网络号，后8位为主机号，类别位为110</span><br><span class="line">D类：没有网络号，类别位为1110</span><br><span class="line">E类：没有网络号，类别位为1111</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;我们可以通过类别位来判断IP地址属于哪一类，也可以通过查看IP地址处在哪个地址范围来判断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A类：  0.0.0.0 ~ 127.255.255.255</span><br><span class="line">B类：128.0.0.0 ~ 191.255.255.255</span><br><span class="line">C类：192.0.0.0 ~ 223.255.255.255</span><br><span class="line">D类：224.0.0.0 ~ 239.255.255.255</span><br><span class="line">E类：240.0.0.0 ~ 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;比如192.168.0.1，在192.0.0.0~223.255.255.255这个区间，所以这是一个C类地址；另外将其转换成二进制后，为11000000 10101000 00000000 00000001，前三位为110，这也可以判断它是一个C类地址。</p>
<p>&#160; &#160; &#160; &#160;但是，并非所有的IP地址我们都能使用，因为有些地址有特殊的用途，我们一般不能使用。</p>
<h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><p>&#160; &#160; &#160; &#160;这里我们只讨论ABC这三类单播地址。</p>
<p>&#160; &#160; &#160; &#160;RFC3330（如今已被RFC5735淘汰）中指明了哪些IP有特殊用途，哪些不能出现在公共互联网上，哪些不能被人们使用，这里我挑几个常见的给大家介绍一下。</p>
<p>&#160; &#160; &#160; &#160;首先要说明一下三种情况，只要符合下列情况之一的IP地址，一般都不会使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">网络号为全0：表示本网络</span><br><span class="line">主机号为全0：表示本主机连接的网络地址</span><br><span class="line">主机号为全1：表示这个网络中的所有主机</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">128.128.255.255：主机号为全1，表示网络128.128.0.0上的所有主机</span><br><span class="line">128.128.0.0：主机号为全0，表示这是网络地址128.128.0.0</span><br><span class="line">0.0.0.128：网络号为全0，表示本网络上主机号为128的主机</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;另外，再介绍两个特殊的IP段：127.0.0.0段和169.254.0.0段。</p>
<p>&#160; &#160; &#160; &#160;127.0.0.0网段大家应该不陌生，特别是做开发的。这个网段中的地址被称为本地环回地址，用于同一设备不同服务之间的通信，发送给这些IP地址的数据都会返回给本机，通常都是使用127.0.0.1这个IP地址。后来在RFC6761中，将域名localhost保留了下来，用于环回，这也是为什么在电脑上搭建服务器，访问localhost和访问127.0.0.1都是同一页面的原因。</p>
<p>&#160; &#160; &#160; &#160;169.254.0.0网段。不知道大家平时有没有注意，给自己电脑配置IP地址，有时会弹出地址冲突的提示，然后查看属性，发现IP地址变成了169.254.0.0网段中的某个IP地址。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-1/3-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%B1%9E%E6%80%A7.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;RFC3927中详细介绍了169.254.0.0网段，这个网段中的IP地址被称为本地链路地址。</p>
<p>&#160; &#160; &#160; &#160;要与其他设备通信，主机就必须配有IP地址，要么手动配置，要么自动获取，但是配置的IP地址并不总是有效的，这样就无法和其他设备通信。</p>
<p>&#160; &#160; &#160; &#160;而本地链路地址的存在就是为了解决这个问题，即使配置的IP地址不是有效的，但依然能分配一个本地链路地址给主机，让主机和其他设备通信。但是本地链路地址只能与同一物理链路中的设备通信，这也是其称为本地链路地址的原因。</p>
<p>&#160; &#160; &#160; &#160;最后要介绍一下0.0.0.0这个IP地址，网络号为0，主机号也为0，在服务器中，0.0.0.0可以表示“本地计算机上的所有IPv4地址”。如果主机有两个IP地址192.168.1.1和10.1.2.1，并且主机上运行的服务器配置为监听0.0.0.0，那么这两个IP地址都可以访问这台主机。</p>
<p>&#160; &#160; &#160; &#160;当然，还有其他的一些IP段不能使用，这里就不再赘述。特殊IP的知识大家心里有个印象就行，不需死记硬背。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-1/4-%E5%8F%AF%E7%94%A8%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4.jpg" class>
</div>




<p>&#160; &#160; &#160; &#160;另外，为了缓解IPv4地址的耗尽，出现了各种技术：NAT、专用网络（私有地址）、DHCP、虚拟主机等，接下来我们就简单介绍一下专用网络，其他几种技术后续再讲。</p>
<h2 id="专用网络（私有地址）"><a href="#专用网络（私有地址）" class="headerlink" title="专用网络（私有地址）"></a>专用网络（私有地址）</h2><p>&#160; &#160; &#160; &#160;RFC1918中指出，专用网络分为三个地址段，这些地址段在专用网络外不能路由，专用网络内的主机不能直接与公共网络通信，换句话说就是这些地址只能用于内部网络。但可以通过网络地址转换（NAT），实现和互联网通信。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A类：10.0.0.0 ~ 10.255.255.255</span><br><span class="line">B类：172.16.0.0 ~ 172.31.255.255</span><br><span class="line">C类：192.168.0.0 ~ 192.168.255.255</span><br></pre></td></tr></table></figure>

<p>&#160; &#160; &#160; &#160;举个最简单的例子，家里的wifi。现在家家户户基本都有wifi，手机、电脑、电视等都可以连接以获取互联网服务。这些设备想要上网，就必须配有正确的IP地址，分配工作是路由器来完成的，而路由器分配给这些设备的IP地址就是私有地址，通常都是192.168.x.x。</p>
<p>&#160; &#160; &#160; &#160;在划分专用网络之前，全球只能有一个192.168.0.1的地址。但划分专用网络之后，每个局域网都可以有一个192.168.0.1的地址，这就缓解了IPv4地址资源的耗尽。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IPv4地址格式：32位二进制数，通常采用“点分十进制法”来表示IP地址</span><br><span class="line">IPv4地址组成：网络号+主机号</span><br><span class="line">IPv4地址分类：ABCDE类，常用的是ABC三类单播地址，D类为多播地址，E类保留</span><br><span class="line">保留地址：有些IP地址被保留，用于特殊用途，其中包括专用网络</span><br><span class="line">A类：10.0.0.0 ~ 10.255.255.255</span><br><span class="line">B类：172.16.0.0 ~ 172.31.255.255</span><br><span class="line">C类：192.168.0.0 ~ 192.168.255.255</span><br></pre></td></tr></table></figure>







<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-1/5-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>





]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>网络层 | 网际协议IP(2)</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;在《网络层 | 网际协议IP（1）》中，我们讲了IPv4地址的格式、分类、特殊IP地址和私有地址，今天我们来讲一讲划分子网和构成超网。</p>
<p>&emsp;&emsp;之前也提到过，早期的IP地址是没有分类的。但随着IP地址资源枯竭问题的产生，后来出现了分类网络，划分子网，无类别域间路由（CIDR）（超网）。</p>
<h1 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h1><p>&emsp;&emsp;分类网络虽然缓解了IP地址资源消耗的速度，但还是存在不合理的地方。</p>
<p>&emsp;&emsp;以一个企业为例。如果申请一个C段，最多可分配2^8-2=254个地址；如果申请一个B段，最多可分配2^16-2=65534个地址。在两者的选择中，他们通常是选择申请B类地址，以应对后续企业的发展，这就造成了IP地址的浪费。因此，很有必要提高IP地址资源的利用率。</p>
<p>&emsp;&emsp;在提出划分子网这个概念的时候，那时候其实还没有分类网络。划分子网，将二级IP变成三级IP，更加灵活，减轻路由表负担；而且可以将一个网络划分为多个子网，而不用去获取一组网络，这样能够很好地满足组织内部需求，详情可查阅RFC950。</p>
<p>&emsp;&emsp;在划分子网之前，IP地址=网络号+主机号；划分子网后，IP地址=网络号+子网号+主机号。</p>
<p>&emsp;&emsp;注意，无论是否划分子网，IP地址都是32位二进制数，并不是说划分子网后，IP地址就变成了32位以上的二进制数。划分子网后，网络号是不变的，只是从主机号中借用若干位作为子网号而已。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/1.jpg" class>
</div>




<p>&emsp;&emsp;另外，子网是相对组织内部而言的。对外部来说，IP“网络号”=网络号。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/2.jpg" class>
</div>



<p>&emsp;&emsp;如上图，从外部来看，所有设备的网络号都是145.13.0.0。而当数据到达组织内部的时候，IP”网络号“=网络号+子网号。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/3.jpg" class>
</div>




<p>&emsp;&emsp;这里要说的是，IP协议传输数据是通过IP数据报（后续会讲），但IP数据报和IP地址里并没有任何关于子网的信息。</p>
<p>&emsp;&emsp;那么当数据到达组织内部时，如何知道该将数据发往哪个子网呢？这个时候就要借助子网掩码了。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>&emsp;&emsp;子网掩码和IP地址一样，也是32位二进制数，也采用“点分十进制”记法，但子网掩码通常是由连续的1和0组成。1用来标记网络位，0用来标记主机位。</p>
<p>&emsp;&emsp;另外，互联网标准规定所有网络都要使用子网掩码。这样做有什么好处？不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的“与”运算就可以得出网络地址。</p>
<p>&emsp;&emsp;如果没有划分子网，则使用默认子网掩码。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/4.jpg" class>
</div>




<p>&emsp;&emsp;如果划分了子网，则将网络号+子网号对应的位掩码置1，主机号对应的位掩码依然为0。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/5.jpg" class>
</div>



<p>&emsp;&emsp;下面我们举个实例，来加深大家的理解。172.16.123.1是一个B类地址，未划分子网时网络号和主机号各16位，默认子网掩码为255.255.0.0。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/6.jpg" class>
</div>




<p>&emsp;&emsp;如上图，我将位掩码设置为18位，也就是说有18-16=2位子网号位，那么子网掩码应该是由18个连续的1和14个连续的0组成。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/7.jpg" class>
</div>



<p>&emsp;&emsp;然后我们把IP地址和子网掩码逐位“与”运算，我们就得出了该IP地址的网络地址为172.16.64.0。</p>
<p>&emsp;&emsp;“与”运算大家应该都学过吧，和小学的算术一样，将每一位对齐。只有两个1相“与”，结果才为1；两个数中有任何一个数为0，那么结果都为0。</p>
<p>&emsp;&emsp;得出了网络地址，那我们就很容易得出在172.16.64.0这个子网中可用的IP地址范围：172.16.64.1~172.16.127.254。</p>
<p>&emsp;&emsp;怎么得出来的？相信大家看了之前的《网络层 | 网际协议IP（1）》应该都能明白。如果还是不明白，那只能怪我讲的不清晰：主机号全0和全1我们一般都不使用。</p>
<p>&emsp;&emsp;另外大家有没有发现，截图中最大IP的第三个8位，两位子网号和六位主机号一同被转换为十进制的127了，所以大家不要以为点分十进制的每位数就是代表网络号或主机号。比如什么172.16.0.0是网络号，0.0.127.254是主机号；或者172.16.127.0是网络号，0.0.0.254是主机号。</p>
<p>&emsp;&emsp;点分十进制只是为了让我们人类方便查看和记忆而已，因此大家不要有：“欸，怎么把子网号和主机号合并成八位转换成十进制了呢？“这种想法；IP地址其实质是一个32位二进制数，要得出网络号和主机号，依赖于子网掩码。</p>
<h1 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h1><p>&emsp;&emsp;分类网络和划分子网等技术虽然缓解了IP地址资源消耗的速度，但依然没办法阻止IP地址资源的耗尽。因此，为了进一步提高IP地址的利用率，IETF研究出了无类别域间路由（CIDR）。详情可查阅RFC4632。</p>
<p>&emsp;&emsp;CIDR主要有三个特点：无类、前缀、地址块。</p>
<p>&emsp;&emsp;CIDR是基于可变长子网掩码的无类别编址方法，没有了ABC类地址，以及在主机号中借用若干位做为子网号的概念，所有IP地址都是无类别的。</p>
<p>&emsp;&emsp;CIDR将32位的IP地址分为前后两部分，前部分称为前缀，指明将32位IP地址中的哪些位解释为网络号，哪些位用于对内部的各个终端进行编号。IP=前缀+主机号，IP地址的网络号不再限定为8位、16位以及24位，更加灵活。</p>
<p>&emsp;&emsp;CIDR将前缀相同的连续的IP地址组成地址块，并采用“斜线记法”来表示IP地址，也称为CIDR记法。</p>
<p>&emsp;&emsp;“斜线记法”在“点分十进制”的IP地址后跟上一条斜线“/”，然后在斜线后写上前缀所占的位数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">128.14</span><span class="number">.35</span><span class="number">.7</span>/<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上所示，就是“斜线记法”。我们不仅能简单的识别出IP地址为128.14.35.7，网络前缀为20位（也就是网络号有20位），还可以计算出该IP属于哪个CIDR地址块，该CIDR地址块的IP地址范围。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/8.jpg" class>
</div>




<p>&emsp;&emsp;把主机位全部置0，即可得出IP属于128.14.32.0/20这个地址块，同时可用的地址范围为128.14.32.1~128.14.47.254。</p>
<p>&emsp;&emsp;另外，CIDR没有了划分子网这个概念，是指没有在主机位中再借用若干位作为子网号而已，使用CIDR地址块的单位依然可以在内部划分出子网。具体的做法是，在主机位中借用若干位，延长前缀的位数，IP还是=前缀+主机号。</p>
<p>&emsp;&emsp;比如在128.14.32.0/20这个地址块中划分4个子网，那么我们需要在主机号中借用两位，将前缀延长到22位，这样128.14.32.0/20这个地址块就有了以下四个子网：</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/9.jpg" class>
</div>




<p>&emsp;&emsp;CIDR不仅提高了IP地址的利用率，同时实现了路由聚合，因为也被称为“构成超网”，路由的知识我会在后面介绍，这里我们只专注于IP地址的发展历程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">划分子网：</span><br><span class="line">    <span class="number">1</span>、二级IP变三级IP：网络号+子网号+主机号</span><br><span class="line">    <span class="number">2</span>、网络号不变，从主机号中借用若干位做为子网号，主机号减少相同的位数</span><br><span class="line">    <span class="number">3</span>、子网相对于内部而言，对外依然是二级IP，对内才是三级IP</span><br><span class="line">    <span class="number">4</span>、根据子网掩码来判断该将数据发送到哪个子网</span><br><span class="line">    <span class="number">5</span>、子网掩码与IP地址相与即可得出IP地址的网络号</span><br><span class="line">构成超网：</span><br><span class="line">    <span class="number">1</span>、无类、前缀、地址块</span><br><span class="line">    <span class="number">2</span>、斜线记法</span><br></pre></td></tr></table></figure>



<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>&#160; &#160; &#160; &#160;安全小白团是帮助用户了解信息安全技术、安全漏洞相关信息的微信公众号。安全小白团提供的程序(方法)可能带有攻击性，仅供安全研究与教学之用，用户将其信息做其他用途，由用户承担全部法律及连带责任，安全小白团不承担任何法律及连带责任。</p>
<div align="center">
    <img src="/%E7%BD%91%E7%BB%9C%E5%B1%82-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP-2/10-%E5%85%B3%E6%B3%A8%E5%85%AC%E4%BC%97%E5%8F%B7.gif" class>
</div>





]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>
